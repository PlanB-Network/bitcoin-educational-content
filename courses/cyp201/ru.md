---
name: Введение в криптографию Биткойн
goal: Понять создание Биткойн кошелька с криптографической точки зрения
objectives:
  - Разъяснить криптографическую терминологию, связанную с Биткойн.
  - Освоить создание Биткойн кошелька.
  - Понять структуру Биткойн кошелька.
  - Понять адреса и пути производных.
---

# Путешествие в мир криптографии

Вас очаровывает Биткойн? Интересуетесь, как работает Биткойн кошелек? Приготовьтесь к захватывающему путешествию в мир криптографии! Loïc, наш эксперт, проведет вас через сложности создания Биткойн кошелька, раскрывая тайны пугающих технических терминов, такими как хеширование, производные ключи и эллиптические кривые.

Это обучение не только даст вам знания для понимания структуры Биткойн кошелька, но и подготовит к глубокому погружению в захватывающий мир криптографии. Так что, готовы ли вы отправиться в это путешествие? Присоединяйтесь к нам и превратите свое любопытство в экспертизу!

+++

# Введение

<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## Введение в криптографию

<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

### Этот курс для вас? ДА!

Мы рады приветствовать вас на новом курсе под названием "Крипто 301: Введение в криптографию и HD кошельки", который ведет эксперт в этой области, Лоик Морель (Loïc Morel). Этот курс погрузит вас в увлекательный мир криптографии, фундаментальной дисциплины математики, которая обеспечивает шифрование и безопасность ваших данных.

В нашей повседневной жизни, и особенно в мире Биткойн, криптография играет ключевую роль. Концепции, связанные с криптографией, такие как приватные ключи, публичные ключи, адреса, пути деривации, сид и энтропия, являются основой использования и создания Биткойн кошелька. На протяжении этого курса Лоик подробно объяснит, как генерируются приватные ключи и как они связаны с адресами. Лоик также посвятит час объяснению математических деталей эллиптических кривых. Кроме того, вы поймете, почему использование HMAC SHA512 важно для защиты твоего кошелька и в чем разница между сид фразой и мнемонической фразой.
Конечная цель этого обучения - помоч вам понять технические процессы, участвующие в создании HD кошелька, и используемые криптографические методы. Со временем Биткойн кошельки эволюционировали, становясь проще в использовании, более безопасными и стандартизированными благодаря определенным BIP. Лоик поможет вам понять эти BIP, чтобы осознать выбор, сделанный разработчиками Биткойн и криптографами. Как и все курсы, предлагаемые нашим университетом, этот курс абсолютно бесплатен и имеет открытый исходный код. Это означает, что вы можете свободно проходить его и использовать по своему усмотрению. Мы с нетерпением ждем от каждого из вас обратной связи в конце этого захватывающего курса.

### Слово предоставляется профессору!

Всем привет, я Лоик Морель, ваш проводник в этом техническом исследовании криптографии, используемой в Биткойн кошельках.

Наше путешествие начинается с погружения в глубины криптографических хеш-функций. Вместе мы разберем внутреннее устройство необходимого SHA256 и исследуем различные алгоритмы, посвященные деривациям (выводам).

Мы продолжим наше приключение, расшифровывая таинственный мир цифровых подписей. Вы узнаете, как магия эллиптических кривых применяется к этим подписям, и мы осветим, как рассчитать публичный ключ из приватного ключа. И, конечно, мы погрузимся в процесс цифровой подписи.

Далее мы вернемся назад во времени, чтобы увидеть эволюцию Биткойн-кошельков, а также погрузимся в концепции энтропии и случайных чисел. Мы рассмотрим знаменитую мнемоническую фразу, не забывая и о парольной фразе. У вас даже будет уникальная возможность создать сид из 128 бросков кубика!

С такой прочной основой мы будем готовы к ключевой части: созданию Биткойн-кошелька. От рождения сида и мастер-ключа, до изучения расширенных ключей и вывода пар ключей - каждый шаг будет детально разобран. Мы также обсудим структуру кошелька и пути вывода.

В завершение нашего путешествия мы рассмотрим Биткойн-адреса. Мы объясним, как они создаются и какую важную роль они играют в функционировании Биткойн-кошельков.

Присоединяйтесь ко мне в этом увлекательном путешествии и будьте готовы исследовать мир криптографии как никогда раньше. Оставьте свои предубеждения у двери и откройте свой ум для нового понимания Биткойна и его фундаментальной структуры.

# Хеш-функции

<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## Введение в криптографические хеш-функции, связанные с Биткойном

<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

Добро пожаловать на сегодняшнее занятие, посвященное глубокому погружению в криптографический мир хеш-функций, ключевого камня безопасности протокола Биткойна. Представьте себе хеш-функцию как ультраэффективного криптографического робота, который преобразует информацию любого размера в уникальный и фиксированный цифровой отпечаток, называемый "хеш", "дайджест" или "контрольная сумма".
Вкратце, хеш-функция принимает входное сообщение произвольного размера и преобразует его в выходной отпечаток фиксированного размера.

Описание профиля криптографических хеш-функций требует понимания двух основных качеств: их необратимости и устойчивости к подделке.

Необратимость, или устойчивость к прямому образу, означает, что вычисление выходных данных по входным может быть выполнено легко, но вычисление входных данных по выходным невозможно.
Это односторонняя функция.

![image](assets/image/section1/0.webp)

Устойчивость к подделке обусловлена тем, что даже незначительное изменение входных данных приведет к существенно различному выходному результату.
Эти функции позволяют проверять целостность загружаемого программного обеспечения.

![image](assets/image/section1/1.webp)

Еще одна важная характеристика - это устойчивость к коллизиям и второму прямому образу. Коллизия происходит, когда два разных ввода производят одинаковый вывод.
Конечно, в мире хеширования коллизии неизбежны, но отличная криптографическая хеш-функция сводит их к минимуму. Риск должен быть настолько низким, что его можно считать пренебрежимо малым. Это как если бы каждый хеш был домом в огромном городе; несмотря на огромное количество домов, хорошая хеш-функция обеспечивает уникальность адреса каждого дома.

Устойчивость к второму прямому образу зависит от устойчивости к коллизиям; если есть устойчивость к коллизиям, то есть устойчивость и ко второму прямому образу.
Имея заданную входную информацию, мы должны найти второй ввод, отличный от первого, который производит коллизию в выходном хеше функции. Устойчивость ко второму прямому образу аналогична устойчивости к коллизиям, за исключением того, что ввод задан.
Давайте теперь перейдем к обсуждению устаревших хеш-функций. SHA0, SHA1 и MD5 сейчас считаются ржавыми оболочками в океане криптографического хеширования. Их часто не рекомендуют использовать, поскольку они потеряли свою устойчивость к коллизиям. Принцип Дирихле объясняет, почему, несмотря на все наши усилия, избежать коллизий невозможно из-за ограничения размера выходных данных. Чтобы действительно считаться безопасной, хеш-функция должна быть устойчива к коллизиям, вторым прообразам и прообразам.

Ключевым элементом в протоколе Биткойн является хеш-функция SHA-256, которая является капитаном корабля. Другие функции, такие как SHA-512, используются для деривации с HMAC и PBKDF. Кроме того, RIPMD160 используется для сокращения отпечатка до 160 бит. Когда мы говорим о HASH256 и HASH160, мы имеем в виду использование двойного хеширования с SHA-256 и RIPMD.

Для HASH256 это двойное хеширование сообщения с использованием функции SHA256.

$$
SHA256(SHA256(сообщение))
$$

Для HASH160 это двойное хеширование сообщения сначала с использованием SHA256, затем RIPMD160.

$$
RIPMD160(SHA256(сообщение))
$$

Использование HASH160 особенно выгодно, поскольку это позволяет обеспечить безопасность SHA-256, уменьшая при этом размер отпечатка.

В заключение, конечная цель криптографической хеш-функции - преобразовать информацию произвольного размера в отпечаток фиксированного размера. Чтобы быть признанной безопасной, она должна обладать несколькими качествами: необратимостью, устойчивостью к подделке, устойчивостью к коллизиям и устойчивостью к второму прообразу.

![изображение](assets/image/section1/2.webp)

В конце этого исследования мы разгадали тайны криптографических хеш-функций, выделили их использование в протоколе Биткойн и проанализировали их конкретные цели. Мы узнали, что для того чтобы хеш-функции считались безопасными, они должны быть устойчивы к прообразам, вторым прообразам, коллизиям и подделке. Мы также рассмотрели различные хеш-функции, используемые в протоколе Биткойн. В нашем следующем сеансе мы погрузимся в суть хеш-функции SHA256 и откроем для себя увлекательную математику, которая придает ей уникальные характеристики.

## Внутреннее устройство SHA256

<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>

Добро пожаловать в продолжение нашего увлекательного путешествия по криптографическим лабиринтам хеш-функции. Сегодня мы раскроем тайны SHA256, сложного, но гениального процесса, который мы ранее представили.
Напомним, что цель хеш-функции SHA256 состоит в том, чтобы взять входное сообщение любого размера и сгенерировать 256-битный хеш в качестве выхода.

### Предварительная обработка

Давайте продвинемся дальше в этом лабиринте, начав с предварительной обработки SHA256.

#### Добавление битов

Цель этого первого шага - получить сообщение, равное кратному 512 битам. Для этого мы добавим дополнительные биты к сообщению.

Пусть M будет начальным размером сообщения.
Пусть 1 будет битом, зарезервированным для разделителя.
Пусть P будет количеством битов, используемых для дополнения, а 64 - количество битов, отведенных для второй фазы предварительной обработки.
Общее количество должно быть кратно 512 битам, которое мы обозначим за n.

![изображение](assets/image/section1/3.webp)

Пример с входным сообщением в 950 бит:

```
Шаг 1: Определите размер; желаемое конечное количество бит.
Первое кратное 512 > (M + 64 + 1) (где M = 950) равно 1024.
1024 = 2 * 512
Таким образом, n = 2.

Шаг 2: Определите P, количество дополнительных битов, необходимых для достижения желаемого конечного числа битов.
-> M + 1 + P + 64 = n * 512
-> M + 1 + P + 64 = 2 * 512
-> 950 + 1 + P + 64 = 1024
-> P = 1024 - 1 - 64 - 950
-> P = 9

Следовательно, необходимо добавить 9 дополнительных битов, чтобы сообщение стало кратным 512.
```

И что теперь?
Сразу после исходного сообщения следует разделитель 1 и за ним следует P, которое в нашем примере равно девяти нулям, которые надо добавить

```
сообщение + 1 000 000 000
```

#### Размера дополнения

Теперь мы переходим ко второй фазе предварительной обработки, которая включает добавление двоичного представления размера исходного сообщения в битах.

Давайте вернемся к примеру с вводом в 950 бит:

```
Двоичное представление числа 950: 11 1011 0110

Мы используем наши 64 зарезервированных бита из предыдущего шага. Мы добавляем нули, чтобы округлить наши 64 бита до нашего выровненного ввода. Затем мы объединяем исходное сообщение, дополнительные биты и размер дополнения, чтобы получить наш выровненный ввод.
```

Вот результат:

![изображение](assets/image/section1/4.webp)

### Обработка

#### Понимание предпосылок

##### Константы и начальные векторы

Теперь мы готовимся к начальным шагам обработки функции SHA-256. Как и в любом хорошем рецепте, нам нужны некоторые базовые ингредиенты, которые мы называем константами и начальными векторами.

Начальные вектора, от A до H, являются первыми 32 битами десятичных частей квадратных корней первых 8 простых чисел. Они будут служить базовыми значениями в начальных шагах обработки. Их значения представлены в шестнадцатеричном формате.

Константы K, от 0 до 63, представляют первые 32 бита десятичных частей кубических корней первых 64 простых чисел. Они используются в каждом раунде функции сжатия. Их значения также представлены в шестнадцатеричном формате.

![изображение](assets/image/section1/5.webp)

##### Используемые операции

В функции сжатия мы используем специфические операторы, такие как XOR, AND и NOT. Мы обрабатываем биты по одному в соответствии с их позицией, используя оператор XOR и таблицу истинности. Оператор AND используется для возвращения 1, только если оба операнда равны 1, а оператор NOT используется для возвращения противоположного значения операнда. Мы также используем операцию SHR для сдвига битов вправо на выбранное число.

Таблица истинности:

![изображение](assets/image/section1/6.webp)

Операции со сдвигом битов:

![изображение](assets/image/section1/7.webp)

#### Функция сжатия

Перед применением функции сжатия мы делим ввод на блоки по 512 бит. Каждый блок обрабатывается независимо от других.

Каждый 512-битный блок затем делится на 32-битные части, называемые W. Таким образом, W(0) представляет первые 32 бита 512-битного блока. W(1) представляет следующие 32 бита и так далее, пока мы не достигнем 512 бит блока.

Как только все константы K и блоки W определены, мы можем выполнить следующие расчеты для каждого блока W в каждом раунде.

Мы выполняем 64 раунда расчетов в функции сжатия. В последнем раунде, на уровне "Вывод функции", у нас будет промежуточное состояние, которое будет добавлено к исходному состоянию функции сжатия.

Затем мы повторяем все эти шаги функции сжатия для следующего 512-битного блока, до последнего блока.

Все сложения в функции сжатия являются сложениями по модулю 2^32, чтобы всегда сохранять 32-битную сумму.

![изображение](assets/image/section1/9.webp)

![изображение](assets/image/section1/8.webp)

##### Один раунд функции сжатия

![изображение](assets/image/section1/11.webp)

![изображение](assets/image/section1/10.webp)

Функция сжатия будет выполнена 64 раза. У нас есть наши части W и ранее определенные константы K в качестве вводных данных.
Красные квадраты/кресты соответствуют сложению по модулю 2^32 бит.

Входные данные A, B, C, D, E, F, G, H будут ассоциированы с 32-битным значением, чтобы в сумме получить 32 \* 8 = 256 бит.
У нас также есть новая последовательность A, B, C, D, E, F, G, H в качестве данных вывода. Этот вывод затем будет использоваться в качестве вводных данных для следующего раунда и так далее до конца 64-го раунда.

Значения вводной последовательности для первого раунда функции сжатия соответствуют ранее упомянутым предопределенным векторам инициализации.
Напомним, что векторы инициализации представляют собой первые 32 бита десятичных частей квадратных корней из первых 8 простых чисел.

Вот пример раунда:

![изображение](assets/image/section1/12.1.webp)

##### Промежуточное состояние

Напомним, что сообщение делится на блоки по 512 бит, которые затем делятся на 32-битные части. Для каждого 512-битного блока мы применяем 64 раунда функции сжатия.
Промежуточное состояние соответствует концу 64 раундов блока. Значения вывода последовательности из 64-го раунда используются в качестве начальных значений для вводной последовательности первого раунда следующего блока.

![изображение](assets/image/section1/12.2.webp)

#### Обзор хеш-функции

![изображение](assets/image/section1/13.webp)

Мы можем заметить, что выход первой 512-битной части сообщения соответствует нашим векторам инициализации в качестве вводных данных для второй 512-битной части сообщения и так далее.

Вывод последнего раунда последней части соответствует окончательному результату функции SHA256.

В заключение мы хотели бы подчеркнуть критическую роль расчетов, выполняемых в блоках CH, MAJ, σ0 и σ1. Эти операции, среди прочего, являются стражами, обеспечивающими надежность хеш-функции SHA256 против атак, делая ее предпочтительным выбором для защиты многих цифровых систем, особенно в протоколе Биткойн. Очевидно, что, несмотря на сложность, красота SHA256 заключается в ее способности находить входные данные по хешу, в то время как проверка хеша для заданных входных данных является механически простым действием.

## Алгоритмы, используемые для деривации

<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>

Алгоритмы HMAC и PBKDF2 являются ключевыми компонентами механизма безопасности протокола Биткойн. Они предотвращают множество потенциальных атак и обеспечивают целостность кошельков Биткойн. HMAC и PBKDF2 - это криптографические инструменты, используемые для различных задач в Биткойне. HMAC в первую очередь используется для противодействия атакам на расширение длины при выводе иерархически детерминированных (HD) кошельков, в то время как PBKDF2 используется для преобразования мнемонической фразы в сид.

#### HMAC-SHA512

Пара HMAC-SHA512 имеет два вводных элемента: сообщение m (Ввод 1) и ключ K, произвольно выбранный пользователем (Ввод 2). Также имеет фиксированный размер вывода: 512 бит.

Давайте отметим:

- m: сообщение произвольного размера, выбранное пользователем (ввод 1)
- K: произвольный ключ, выбранный пользователем (ввод 2)
- K': выравненный ключ K. Он был скорректирован до размера B блоков.
- ||: операция конкатенации.
- opad: константа, определенная байтом 0x5c, повторенная B раз.
- ipad: константа, определенная байтом 0x36, повторенная B раз.
- B: Размер блоков используемой хеш-функции.

![image](assets/image/section1/14.webp)

HMAC-SHA512, который принимает сообщение и ключ в качестве вводных данных, генерирует вывод фиксированного размера. Для обеспечения единообразия ключ корректируется в зависимости от размера блоков, используемых в хеш-функции. В контексте вывода HD кошелька используется HMAC-SHA-512. Он работает с 1024-битными (128-байтными) блоками и соответственно корректирует ключ. Используются константы OPAD (0x5c) и IPAD (0x36), повторяемые по мере необходимости для повышения безопасности.

Процесс HMAC-SHA-512 включает конкатенацию результата применения SHA-512 к ключу XOR OPAD и ключу XOR IPAD с сообщением. При использовании с 1024-битными (128-байтными) блоками входной ключ при необходимости дополняется нулями, затем применяется XOR с IPAD и OPAD. Модифицированный ключ затем конкатенируется с сообщением.

![image](assets/image/section1/15.webp)

Включение соли в строковый код увеличивает безопасность получаемых ключей. Без нее атака могла бы скомпрометировать весь кошелек и украсть все биткойны.

PBKDF2 используется для преобразования мнемонической фразы в сид. Этот алгоритм выполняет 2048 раундов с использованием HMAC SHA512. Через эти алгоритмы вывода разные входные данные могут производить уникальный и фиксированный выход, что снижает проблему возможных атак удлинением сообщения на функции семейства SHA-2.
Атака удлинением сообщения использует специфическое свойство некоторых криптографических хеш-функций. В такой атаке атакующий, который уже имеет хеш неизвестного сообщения, может использовать его для расчета хеша более длинного сообщения, которое является расширением оригинального сообщения. Это часто возможно без знания содержания оригинального сообщения, что может привести к значительным уязвимостям безопасности, если этот тип хеш-функции используется для задач, таких как проверка целостности.

![image](assets/image/section1/16.webp)

В заключение, алгоритмы HMAC и PBKDF2 играют существенные роли в безопасности вывода HD кошельков в протоколе Биткойн. HMAC-SHA-512 используется для защиты от атак удлинением сообщения, в то время как PBKDF2 позволяет преобразование мнемонической фразы в сид. Строковый код добавляет дополнительный источник энтропии в вывод ключа, обеспечивая надежность системы.

# Цифровые подписи

<partId>76b58a00-0c18-54b9-870d-6b7e34029db8</partId>

## Цифровые подписи и эллиптические кривые

<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

Где хранятся эти знаменитые биткойны? Не в Биткойн-кошельке, как можно было бы подумать. На самом деле, Биткойн-кошелек хранит приватные ключи, необходимые для доказательства владения биткойнами. Сами биткойны записываются в блокчейн, децентрализованную базу данных, которая архивирует все транзакции.

В системе Биткойна единица учета - это биткойн (обратите внимание на маленькую букву "б"). Он делится вплоть до восьми десятичных знаков, где самая маленькая единица называется сатоши. UTXO ("Unspent Transaction Outputs"), или "Непотраченные Выводы Транзакций", представляют собой непотраченные выходы транзакций, принадлежащие публичному ключу, который математически связан с приватным ключом. Чтобы потратить эти биткойны, необходимо выполнить условие траты транзакции. Типичное условие траты включает доказательство остальной части сети, что пользователь является законным владельцем публичного ключа, связанного с UTXO. Для этого пользователь должен продемонстрировать владение приватным ключом, соответствующим публичному ключу, связанному с каждым UTXO, не раскрывая приватный ключ.

Здесь на сцену выходит цифровая подпись. Она служит математическим доказательством владения приватным ключом, связанным с определенным публичным ключом. Эта техника защиты данных в основном основана на увлекательной области криптографии, называемой криптографией на эллиптических кривых (ECC).

Подпись может быть математически проверена другими участниками сети биткойна.

![image](assets/image/section2/0.webp)

Для обеспечения безопасности транзакций Биткойн полагается на два протокола цифровой подписи: ECDSA (Алгоритм Цифровой Подписи на Эллиптических Кривых) и Schnorr. ECDSA был интегрирован в Биткойн с момента его запуска в 2009 году, в то время как подписи Schnorr были добавлены относительно недавно, в ноябре 2021 года. Хотя оба протокола основаны на криптографии эллиптических кривых и используют похожие математические механизмы, они в основном отличаются по структуре подписи.

В этом курсе мы представим алгоритм ECDSA.

### Что такое эллиптическая кривая?

Криптография на эллиптических кривых - это набор алгоритмов, использующих
различные геометрические и математические свойства эллиптических кривы в криптографическом контексте, с безопасностью, основанной на сложности вычисления дискретного логарифма.

Эллиптические кривые полезны в различных криптографических приложениях в протоколе Биткойна, начиная с обмена ключами и заканчивая асимметричным шифрованием и цифровыми подписями.

Эллиптические кривые имеют интересные свойства:

- Симметрия: Любая не вертикальная линия, пересекающая две точки на эллиптической кривой, пересечет кривую в третьей точке.
- Любая не вертикальная линия, касательная к кривой в точке, всегда пересечет кривую в единственной второй точке.

Протокол Биткойна использует специфическую эллиптическую кривую под названием Secp256k1 для своих криптографических операций.

Прежде чем углубляться в механизмы подписи, важно понять, что такое эллиптическая кривая. Эллиптическая кривая определяется уравнением y² = x³ + ax + b. Каждая точка на этой кривой имеет особую симметрию, которая является ключевой для ее использования в криптографии.

![image](assets/image/section2/1.webp)

По большому счету, многие эллиптические кривые являются безопасными для криптографического использования. Наиболее известной может быть кривая secp256r1. Однако для Биткойна Сатоши Накамото выбрал другую кривую: secp256k1.

Эта кривая определяется параметрами a=0 и b=7, а её уравнение имеет вид y² = x³ + 7 по модулю n, где n представляет собой простое число, определяющее порядок кривой.

![image](assets/image/section2/2.webp)

Первое изображение представляет кривую secp256k1 над вещественным полем и её уравнение.
Второе изображение - это представление кривой secp256k1 над полем ZP, полем положительных натуральных чисел, по модулю p, где p - простое число. Это выглядит как облако точек. Мы используем поле положительных натуральных чисел, чтобы избежать приближений.
p является простым числом и представляет собой порядок кривой, который используется.
Наконец, уравнение, используемое в протоколе Биткойна, выглядит следующим образом:

$$y^2 = (x^3 + 7) \mod(p)$$

Уравнение эллиптической кривой в Биткойн соответствует последнему уравнению на предыдущем изображении.

В следующем разделе этого курса мы будем использовать кривые над полем вещественных чисел для облегчения понимания.

## Вычисление публичного ключа по приватному ключу

<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>

Для начала давайте погрузимся в мир алгоритма цифровой подписи на эллиптических кривых (ECDSA). Биткойн использует алгоритм цифровой подписи для связывания приватных и публичных ключей. В этой системе приватный ключ представляет собой случайное или псевдослучайное 256-битное число. Теоретически общее количество возможностей для приватного ключа составляет $2^256$, но на самом деле это немного меньше. Более точно, некоторые 256-битные приватные ключи не действительны для Биткойна.

Чтобы быть совместимым с Биткойн, приватный ключ должен быть между 1 и n-1, где n представляет порядок эллиптической кривой. Это означает, что общее количество возможностей для приватного ключа Биткойн почти равно $1.158 \times 10^{77}$. Для сравнения, это число примерно такое же как количество атомов, присутствующих в наблюдаемой вселенной.

![image](assets/image/section2/3.webp)

Уникальный приватный ключ, обозначаемый как k, затем используется для определения публичного ключа.

Публичный ключ, обозначаемый как K, является точкой на эллиптической кривой, которая получается из приватного ключа с использованием необратимых алгоритмов, таких как ECDSA. Когда у нас есть знание приватного ключа, получить публичный ключ очень легко, но когда у нас есть только публичный ключ, получить приватный ключ невозможно. Эта необратимость является краеугольным камнем безопасности Биткойн кошелька.

Публичный ключ имеет длину 512 бит, поскольку он соответствует точке на кривой с x-координатой 256 бит и y-координатой 256 бит. Однако его можно сжать до 264-битного числа.

![image](assets/image/section2/4.webp)

Точка генерации (G) - это точка на кривой, из которой в протоколе Биткойн генерируются все публичные ключи. Она имеет конкретные координаты x и y, обычно представленные в шестнадцатеричном формате. Для secp256k1 координаты G в шестнадцатеричном формате выглядят следующим образом:

- `Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798`
- `Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8`

Эта точка полезна для вывода всех публичных ключей. Чтобы вычислить публичный ключ K, просто умножьте точку G на приватный ключ k, так что: K = k.G

Далее мы изучим, как складывать и умножать точки на эллиптических кривых.

#### Сложение и удвоение точек на эллиптических кривых

##### Сложение двух точек M + L

Одно из замечательных свойств эллиптических кривых заключается в том, что не вертикальная линия, пересекающая кривую в двух точках, также пересечет ее в третьей точке, обозначенной точкой O в нашем примере. Это свойство используется для определения точки U, которая является противоположной точке O относительно оси $x$.

M + L = U

![изображение](assets/image/section2/5.webp)

##### Сложение точки самой с собой = Удвоение точки

Сложение точки G самой с собой выполняется путем проведения касательной к кривой в этой точке. Эта касательная, согласно свойствам эллиптических кривых, пересечет кривую во второй уникальной точке -J. Противоположная этой точке, J, является результатом сложения точки G самой с собой.
G + G = J

Фактически, точка G является исходной точкой для расчета всех публичных ключей пользователей системы Биткойн.

![изображение](assets/image/section2/6.webp)

#### Скалярное умножение на эллиптических кривых

Скалярное умножение точки на n эквивалентно сложению этой точки самой с собой n раз.

Аналогично удвоению точки, скалярное умножение точки G на n выполняется путем проведения касательной к кривой в точке G. Эта касательная, согласно свойствам эллиптических кривых, пересечет кривую во второй уникальной точке -2G. Противоположная этой точке, 2G, является результатом сложения точки G самой с собой.

Если n = 4, то операция повторяется до достижения 4G.

![изображение](assets/image/section2/7.webp)

Вот пример расчета для 3G:

![изображение](assets/image/section2/8.webp)

Эти операции с точками на эллиптической кривой являются основой для расчета публичных ключей. Получение публичного ключа, зная приватный ключ, очень просто.
Публичный ключ - это точка на эллиптической кривой, она является результатом нашего сложения и удвоения точки G k раз, где k = приватный ключ.

В этом примере:

- Приватный ключ k = 4
- Публичный ключ K = kG = 4G

![изображение](assets/image/section2/9.webp)

Зная приватный ключ k, легко вычислить публичный ключ K. Однако невозможно получить приватный ключ, исходя из публичного ключа. Это результат сложения или удвоения точек?

В нашем следующем уроке мы рассмотрим, как создается цифровая подпись с использованием алгоритма ECDSA с приватным ключом для перевода биткойнов.

## Подписание приватным ключом

<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

Процесс цифровой подписи является ключевым методом доказательства того, что вы являетесь владельцем приватного ключа, не раскрывая его. Это достигается с использованием алгоритма ECDSA, который включает определение уникального кода, nonce (Number Only Used Once), расчет определенного числа V и создание цифровой подписи, состоящей из двух частей, S1 и S2.
Важно всегда использовать уникальный nonce во избежании атак на безопасность. Одним из известных примеров того, что может произойти, когда это правило не соблюдается, является взлом PlayStation 3, который был скомпрометирован из-за повторного использования nonce.

![](assets/image/section2/10.webp)

Шаги:

- Определите nonce v, который является уникальным случайным числом.
  Nonce = Number Only Used Once (Число, используемое только один раз).
  Оно определяется тем, кто выполняет подпись.
- Рассчитайте, добавляя и удваивая точки на эллиптической кривой от точки G, позицию V на эллиптической кривой.
  Таким образом, V = v.G
  x и y являются координатами V на плоскости.
- Рассчитайте S1.
  S1 = x mod n, где n = порядок кривой, а x - координата V на плоскости.
  Примечание: Количество возможных открытых ключей больше, чем количество точек на эллиптической кривой в конечном поле положительных целых чисел, используемом в Биткойн.
  Порядок кривой соответствует только возможностям, которые открытый ключ может принимать на кривой.
- Рассчитайте S2.
  H(Tx) = Хэш транзакцииб
  k = закрытый ключ
- Рассчитайте подпись: конкатенацию S1 + S2.
- Рассчитайте P, вычисление проверки подписи.
  K = открытый ключ

Например, чтобы получить открытый ключ 3G, вы проводите касательную к точке G, рассчитываете противоположность -G, чтобы получить 2G, а затем складываете G и 2G. Для выполнения транзакции вы должны доказать, что знаете число 3, разблокируя биткойны, связанные с открытым ключом 3G.

Чтобы создать цифровую подпись и доказать, что вы знаете закрытый ключ, связанный с открытым ключом 3G, вы сначала рассчитываете nonce, затем точку V, связанную с этим nonce (в данном примере это 4G). Затем вы рассчитываете точку T, добавляя открытый ключ 3G и точку V, что дает 7G.

![image](assets/image/section2/11.webp)

Давайте упростим процесс цифровой подписи.
На предыдущем изображении закрытый ключ k = 3.
Мы можем легко рассчитать открытый ключ K, связанный с этим закрытым ключом: K = 3G.
Затем мы генерируем nonce псевдослучайным образом: v = 4.
Из этого nonce можно рассчитать V так, что: V = v.G = 4G.

Из этой точки V мы рассчитываем точку T так, что:
T = t.G = 7G (где t = 7).

Теперь пришло время приступить к проверке цифровой подписи.

Проверка цифровой подписи является критически важным шагом при использовании алгоритма ECDSA, который позволяет подтвердить подлинность подписанного сообщения без необходимости использования закрытого ключа отправителя. Вот как это работает в деталях:

В нашем примере у нас есть два важных значения: t и V.
t - это числовое значение (7 в этом примере), а V - точка на эллиптической кривой (представлена здесь как 4G). Эти значения генерируются во время создания цифровой подписи и затем отправляются вместе с сообщением для возможности проверки.

Когда проверяющий получает сообщение, он также получает эти два значения, t и V.

Вот шаги, которые проверяющий будет следовать для валидации подписи:

1. Сначала они рассчитают хэш сообщения, который мы будем называть H.
2. Затем они рассчитают $u1$ и $u2$. Для этого они будут использовать следующие формулы:

- $u1 = H * (S2)^{-1} \mod n$
- $u2 = T * (S2)^{-1} \mod n$

  Где $S2$ - вторая часть цифровой подписи, $n$ - порядок эллиптической кривой, и $(S2)^{-1}$ - обратное к $S2$ по модулю $n$.

3. Затем проверяющий вычислит точку $P'$ на эллиптической кривой, используя формулу: $P' = u1 * G + u2 * K$
   - $G$ - генерирующая точка кривой
   - $K$ - публичный ключ отправителя
4. Проверяющий затем вычислит $I'$, которое просто является $x$-координатой точки $P'$ по модулю $n$.
5. Наконец, проверяющий подтвердит, что $I'$ равно t. Если это так, подпись считается действительной. Если нет, подпись недействительна.
   Эта процедура гарантирует, что подпись мог создать только отправитель, обладающий соответствующим закрытым ключом.

![изображение](assets/image/section2/12.webp)

Проще говоря:
Лицо, создающее подпись, предоставит число t (в нашем примере, t = 7) и точку V лицу, проверяющему её.

Невозможно определить публичный ключ или закрытый ключ по числу 7 и точке V.

Шаги для проверки цифровой подписи следующие:

- На кривой проверяющий добавляет точку публичного ключа к точке V, чтобы получить точку T'.
- Проверяющий вычисляет число t.G.
- Проверяющий проверяет, что результат t.G действительно равен числу T'.

В заключение, проверка цифровой подписи является существенной процедурой в транзакциях Биткойн. Это гарантирует, что подписанное сообщение не было изменено во время передачи и что отправитель действительно является владельцем закрытого ключа. Эта техника цифровой аутентификации основана на сложных математических принципах, включая арифметику эллиптических кривых, при этом сохраняя конфиденциальность закрытого ключа. Она обеспечивает надежную основу безопасности для криптографических транзакций.

Тем не менее, управление этими ключами, а также их создание, является еще одним важным вопросом в Биткойне. Как генерировать новую пару ключей? Как безопасно и эффективно организовать множество ключей? Как восстановить их при необходимости?

Чтобы ответить на эти вопросы и углубить ваше понимание безопасности криптографии, наш следующий курс будет сосредоточен на концепции Иерархических Детерминированных Кошельков (HD (Hierarchical Deterministic) кошельков) и использовании мнемонических фраз. Эти механизмы предлагают элегантные способы эффективного управления вашими криптовалютными ключами, повышая при этом безопасность.

# Мнемоническая фраза

<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## Эволюция кошельков Биткойн

<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

Иерархический Детерминированный Кошелек, более известный как HD кошелек (The Hierarchical Deterministic Wallet), играет важную роль в экосистеме криптовалют. Термин "кошелек" может ввести в заблуждение новичков в этой области, поскольку он не подразумевает хранение денег или валют. Вместо этого он относится к коллекции криптографических закрытых ключей.

Ранние кошельки были программным обеспечением, которое группировало закрытые ключи, определенные в псевдослучайном порядке, но не имело между ними связи. Эти кошельки называются "Просто Куча Ключей" ("Just a Bunch Of Keys" - JBOK).

Поскольку ключи не связаны между собой, пользователю требуется создавать новую резервную копию для каждой новой сгенерированной пары ключей.
Будь то пользователь, который всегда использовал одну и ту же пару ключей и скомпрометировал конфиденциальность, или сгенерировал новую пару ключей случайным образом и, следовательно, нуждается в создании новой резервной копии этих ключей.

Однако сложность управления этими ключами компенсируется набором протоколов, называемых Предложениями по Улучшению Биткоина (Bitcoin Improvement Proposals - BIPs). Эти предложения по модернизации лежат в основе функциональности и безопасности HD кошельков. Например, [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), запущенный в 2012 году, коренным образом изменил способ генерации и хранения этих ключей, введя концепцию детерминированных и иерархически производных ключей. Идея состоит в том, чтобы выводить все ключи детерминированно и иерархически из уникального элемента информации: seed (начального числа). Это значительно упрощает процесс резервного копирования этих ключей, сохраняя при этом уровень их безопасности.

Затем [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) представил значительное нововведение: мнемоническую фразу из 24 слов. Эта система преобразовала сложную и трудно запоминаемую последовательность чисел в ряд обычных слов, что значительно упростило их запоминание и хранение. Кроме того, [BIP38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki) предложил добавить дополнительную парольную фразу для повышения безопасности отдельных ключей. Эти последовательные улучшения привели к стандартам BIP43 и BIP44, которые стандартизировали структуру и иерархизацию HD кошельков, сделав их более доступными и удобными для широкой публики.

В следующих разделах мы более подробно рассмотрим принципы работы HD кошельков. Мы обсудим принципы вывода ключей и рассмотрим основные концепции энтропии и генерации случайных чисел, которые имеют решающее значение для обеспечения безопасности HD кошелька.

В заключение важно подчеркнуть центральную роль BIP32 и BIP39 в дизайне и безопасности HD кошельков. Эти протоколы позволяют генерировать множество ключей из одного сида, который должен быть случайным или псевдослучайным числом. Сегодня эти стандарты приняты большинством криптовалютных кошельков, независимо от того, поддерживают ли они одну криптовалюту или несколько типов криптовалют.

## Энтропия и Генерация Случайных Чисел

<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>

Важность безопасности приватных ключей в экосистеме Биткойна неоспорима. Они действительно являются краеугольным камнем, обеспечивающим безопасность транзакций Биткойна. Чтобы избежать любой уязвимости, связанной с предсказуемостью, эти ключи должны генерироваться абсолютно случайным образом, что может быстро стать трудоемким процессом. Проблема заключается в том, что в информатике невозможно сгенерировать абсолютно случайное число, поскольку оно обязательно производится из детерминированного процесса; кода. Вот почему важно узнать о различных Генераторах Случайных Чисел (ГСЧ). Типы ГСЧ варьируются от Генераторов Псевдослучайных Чисел (ГПСЧ) до Истинных Генераторов Случайных Чисел (ИГСЧ), а также ГПСЧ, которые включают источник энтропии.

Энтропия относится к состоянию "беспорядка" системы. Используя внешнюю энтропию, то есть внешний источник информации, становится возможным использовать генератор случайных чисел для получения случайного числа.

![image](assets/image/section3/2.webp)

Давайте посмотрим, как работает Генератор Псевдослучайный Чисел (ГПСЧ).

Он принимает сид в качестве входных данных, который соответствует внутреннему состоянию 0.
К этому внутреннему состоянию применяется функция преобразования, и результат, который является псевдослучайным числом, соответствует внутреннему состоянию 1.
На это внутреннее состояние 1, снова применяется функция преобразования, в результате чего получается новое случайное число = внутреннее состояние 2.
И так далее.

Основным недостатком является то, что любой идентичный сид всегда будет производить один и тот же результат. Также, если мы знаем результат начальных функций преобразования, мы сможем извлечь случайное число на выходе процесса.
Примером функции преобразования является функция PBKDF2.

**В итоге, криптографически безопасный ГСЧ должен:**

- быть статистически случайным
- быть непредсказуемым
- быть устойчивым, даже если результаты будут раскрыты
- иметь достаточно длинный период

![изображение](assets/image/section3/3.webp)

В случае с Биткойном, приватные ключи генерируются из единственного куска информации, который находится основе кошелька. Эта информация позволяет детерминированно и иерархически выводить дочерние пары ключей. Энтропия является основой каждого HD кошелька, хотя нет стандарта для генерации этого случайного числа. Поэтому генерация случайного числа является основной задачей в обеспечении безопасности транзакций Биткойна.

## Мнемоническая фраза

<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>

Безопасность Биткойн кошелька является основной заботой всех его пользователей. Один из основных способов обеспечить резервное копирование кошелька - это генерация мнемонической фразы на основе энтропии и контрольной суммы.

![изображение](assets/image/section3/5.webp)

Чтобы преобразовать энтропию в мнемоническую фразу, надо рассчитать контрольную сумму энтропии и объединить энтропию и контрольную сумму.

После генерации энтропии функция SHA256 применяется к энтропии для создания хеша.
Извлекаются первые 8 бит хеша, которые являются контрольной суммой.
Мнемоническая фраза является результатом добавления к энтропии контрольной суммы.

Контрольная сумма обеспечивает проверку точности восстановительной фразы. Без этой контрольной суммы ошибка во фразе могла бы привести к созданию другого кошелька и, следовательно, к потере средств. Контрольная сумма получается путем пропускания энтропии через функцию SHA256 и извлечения первых 8 бит хеша.

![изображение](assets/image/section3/6.webp)

Существуют различные стандарты для мнемонической фразы в зависимости от размера энтропии. Наиболее часто используемый стандарт для восстановительной фразы из 24 слов - это энтропия в 256 бит. Размер контрольной суммы определяется делением размера энтропии на 32.

Например, энтропия в 256 бит генерирует 8-битную контрольную сумму. Конкатенация энтропии и контрольной суммы затем приводит к соответствующим размерам 128 бит, 160 бит и т. д. В зависимости от размера энтропии, восстановительная фраза будет состоять из 12 слов для 128 бит, из 15 слов для 160 бит и из 24 слов для 256 бит.

**Кодирование мнемонической фразы:**

![изображение](assets/image/section3/7.webp)

Последние 8 бит соответствуют контрольной сумме.
Каждый 11-битный сегмент преобразуется в десятичное число.
Каждое десятичное число соответствует слову из списка из 2048 слов по BIP39. Важно отметить, что ни одно слово не имеет одинакового порядка первых четырех букв.

Важно сохранить резервную фразу из 24 слов для сохранения целостности Биткойн кошелька. Два наиболее часто используемых стандарта основаны на энтропии в 128 или 256 бит и конкатенации 12 или 24 слов. Добавление парольной фразы является дополнительной опцией для повышения безопасности кошелька.

В заключение, генерация мнемонической фразы для обеспечения безопасности Биткойн кошелька является критически важным процессом. Важно придерживаться стандартов мнемонической фразы в зависимости от размера энтропии. Резервное копирование фразы из 24 слов существенно для предотвращения любых потерь средств.

## Парольная фраза

<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>

Парольная фраза является дополнительным паролем, который может быть интегрирован в Биткойн-кошелек для повышения его безопасности. Ее использование является необязательным и зависит от решения пользователя. Добавляя произвольную информацию, которая вместе с мнемонической фразой позволяет вычислить сид кошелька, парольная фраза повышает его безопасность.

![image](assets/image/section3/8.webp)

Парольная фраза является необязательной криптографической "солью" размера, выбранного пользователем. Она улучшает безопасность HD-кошелька, добавляя произвольную информацию, которая в сочетании с мнемонической фразой, позволяет вычислить сид.

После установки во время создания кошелька, она необходима для производства всех ключей кошелька. Функция pbkdf2 используется для генерации сида из парольной фразы. Этот сид позволяет производить все дочерние пары ключей кошелька. Если парольная фраза изменяется, Биткойн-кошелек становится совершенно другим.

Парольная фраза является важным инструментом для повышения безопасности Биткойн-кошельков. Она может позволить реализовать различные стратегии безопасности. Например, ее можно использовать для создания дубликатов и облегчения резервного копирования мнемонической фразы. Также она может улучшить безопасность кошелька, снижая риски, связанные со случайной генерацией мнемонической фразы.

Эффективная парольная фраза должна быть длинной (от 20 до 40 символов) и разнообразной (использовать заглавные буквы, строчные буквы, цифры и символы). Она не должна быть напрямую связана с пользователем или его окружением. Безопаснее использовать случайную последовательность символов, а не простое слово в качестве парольной фразы.

![image](assets/image/section3/9.webp)

Парольная фраза более безопасна, чем простой пароль. Идеальная парольная фраза длинная, разнообразная и случайная. Она может повысить безопасность кошелька или программного обеспечения. Также ее можно использовать для создания дополнительных и безопасных резервных копий.

Крайне важно заботиться о резервных копиях парольной фразы, чтобы избежать потери доступа к кошельку. Парольная фраза является опцией для HD-кошелька. Ее можно генерировать случайным образом с помощью игральных костей или другого генератора псевдослучайных чисел. Не рекомендуется запоминать парольную или мнемоническую фразу.

В нашем следующем уроке мы подробно рассмотрим функционирование сида и первой пары ключей, сгенерированных из него. Не стесняйтесь и продолжайте этот курсом, чтобы продолжить обучение. С нетерпением ждем встречи с вами снова.

# Создание биткойн-кошельков

<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## Создание сида и мастер-ключа

<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

В этой части курса мы изучим шаги по созданию иерархического детерминированного кошелька (HD Wallet), который позволяет иерархически и детерминированно создавать и управлять приватными и публичными ключами.

![image](assets/image/section4/0.webp)

Основа HD-кошелька опирается на два основных элемента: мнемоническую фразу и парольную фразу (дополнительный необязательный пароль). Вместе они составляют сид, алфавитно-цифровую последовательность из 512 бит, которая служит основой для производства ключей кошелька. Из этого сида можно произвести все дочерние пары ключей Биткойн-кошелька. Сид является ключом, который предоставляет доступ ко всем биткойнам, связанным с кошельком, используете вы парольную фразу или нет.

![image](assets/image/section4/1.webp)

Для получения сида используется функция pbkdf2 (Password-Based Key Derivation Function 2) с мнемонической фразой и парольной фразой. Результатом работы pbkdf2 является 512-битный сид.

Из сида можно определить мастер-приватный ключ и код цепочки, используя алгоритм HMAC SHA-512 (Hash-based Message Authentication Code Secure Hash Algorithm 512). Этот алгоритм требует на вход сообщение и ключ для генерации результата. Мастер-приватный ключ вычисляется из сида и фразы "Bitcoin SEED". Эта фраза идентична для всех производных всех HD кошельков, обеспечивая их согласованность.

Изначально функция SHA-512 не была реализована в протоколе Биткойна, поэтому используется HMAC SHA-512. Использование HMAC SHA-512 с фразой "Bitcoin SEED" ограничивает пользователя созданием кошелька, специфичного для Биткойн. Результатом HMAC SHA-512 является 512-битное число, разделенное на две части: крайние левые 256 бит представляют мастер-приватный ключ, в то время как крайние правые 256 бит представляют мастер-код цепочки.

![image](assets/image/section4/2.webp)

Мастер-приватный ключ является родительским ключом всех будущих ключей в кошельке, в то время как мастер-код цепочки участвует в производстве дочерних ключей. Важно отметить, что без знания соответствующего кода цепочки родительской пары невозможно произвести дочернюю пару ключей.

Пара ключей в кошельке состоит из приватного ключа, публичного ключа и кода цепочки. Код цепочки вносит источник случайности в производство дочерних ключей и изолирует каждую пару ключей, чтобы предотвратить утечку информации.
Важно отметить, что мастер-приватный ключ является первым приватным ключом, полученным из сида, и не имеет связи с расширенными ключами кошелька.

В следующем уроке мы подробно рассмотрим расширенные ключи, такие как xPub, xPRV, zPub, и поймем, почему они используются и как они конструируются.

## Расширенные ключи

<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

В этой части урока мы изучим расширенные ключи (xPub, zPub, yPub) и их префиксы, которые играют важную роль в производстве дочерних ключей в Иерархическом Детерминированном Кошельке (HD Wallet).

![image](assets/image/section4/3.webp)

Расширенные ключи отличаются от мастер-ключей. HD кошелек генерирует мнемоническую фразу и сид для получения мастер-ключа и мастер-кода цепочки. Расширенные ключи используются для производства дочерних ключей и требуют как родительский ключ, так и соответствующий код цепочки. Расширенный ключ объединяет эти два элемента информации, чтобы упростить процесс вывода.

![image](assets/image/section4/4.webp)

Расширенные публичные ключи могут создавать только обычные дочерние публичные ключи, в то время как расширенные приватные ключи могут создавать как дочерние публичные, так и приватные ключи, как через обычный, так и через усиленный вывод. Усиленный вывод происходит из родительского приватного ключа, в то время как обычный вывод соответствует выводу из родительского публичного ключа.

Использование расширенных ключей с префиксом XPUB позволяет производить новые адреса без обращения к соответствующим приватным ключам, тем самым обеспечивая лучшую безопасность. Метаданные, связанные с расширенными ключами, предоставляют важную информацию о их роли и позиции в иерархии ключей.

Расширенные ключи идентифицируются по специфическим префиксам (XPRV, XPUB, YPUB, ZPUB), которые указывают, является ли ключ расширенным приватным или публичным, а также его конкретное назначение. Метаданные, связанные с расширенным ключом, включают версию (префикс), глубину, отпечаток родительского ключа, индекс и полезную нагрузку (цепочку кода и родительский ключ).

![image](assets/image/section4/5.webp)

Версия соответствует типу ключа: xpub, xprv, ...

Глубина соответствует количеству выводов между родительскими и дочерними ключами с момента создания мастер-ключа.

Отпечаток родителя - это первые 4 байта хэша 160 родительского ключа.
Индекс - это номер пары, используемой для генерации расширенного ключа среди его "братьев" (братья = ключи той же глубины). Например, если мы хотим получить xpub нашего третьего аккаунта, его индекс будет 2 (потому что индекс начинается с 0).

Полезная нагрузка состоит из цепочки кода (32 байта) и родительского ключа (33 байта).

Сжатые публичные ключи имеют размер 33 байта, в то время как несжатые публичные ключи составляют 512 бит. Сжатые публичные ключи сохраняют ту же информацию, что и несжатые ключи, но с уменьшенным размером. Расширенные ключи имеют размер 82 байта, и их префикс представлен в 58-ричной системе через преобразование в шестнадцатеричный формат. Контрольная сумма рассчитывается с использованием функции хэширования HASH256.

![image](assets/image/section4/6.webp)

Улучшенные выводы начинаются с индексов, которые являются степенями двойки $(2^{31})$. Интересно отметить, что наиболее часто используемые префиксы - это xpub и zpub, которые соответственно соответствуют устаревшим стандартам и segwit v1 и segwit v0.

В нашем следующем уроке мы сосредоточимся на выводе дочерних пар ключей, используя полученные знания о расширенных ключах и мастер-ключе кошелька.

## Вывод дочерних пар ключей

<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

Напомним, мы обсуждали расчет сида и мастер-ключа, которые являются первыми основными элементами для иерархической организации и производства HD (Иерархически Детерминированного) кошелька. Сид, длиной от 128 до 256 бит, генерируется случайным образом или из секретной фразы. Он играет детерминированную роль в производстве всех других ключей. Мастер-ключ - это первый ключ, полученый из сида, и он позволяет получать все другие дочерние пары ключей.

Мастер-цепочка кода играет важную роль в восстановлении кошелька из сида. Следует отметить, что все ключи, полученные из одного и того же сида, будут иметь одну и ту же мастер-цепочку кода.

![image](assets/image/section4/7.webp)

Иерархическая организация и процесс вывода в HD кошельках обеспечивают более эффективное управление ключами и структурами кошелька. Расширенные ключи позволяют производить дочернюю пару ключей из родительской пары ключей с использованием математических расчетов и специфических алгоритмов.
Существуют различные типы дочерних пар ключей, включая усиленные ключи и обычные ключи. Расширенный публичный ключ позволяет выводить только обычные дочерние публичные ключи, в то время как расширенный приватный ключ позволяет производить все дочерние ключи, как публичные, так и приватные, будь то в обычном или усиленном режиме. Каждая пара ключей имеет индекс, который позволяет их различать друг от друга.

![image](assets/image/section4/8.webp)

Вывод дочерних ключей используют функцию HMAC-SHA512, используя родительский ключ, объединенный с индексом и кодом цепи, связанным с парой ключей. Обычные дочерние ключи имеют индекс, варьирующийся от 0 до 2 в степени 31 минус 1, в то время как усиленные дочерние ключи имеют индекс, варьирующийся от 2 в степени 31 до 2 в степени 32 минус 1.

![image](assets/image/section4/9.webp)

![image](assets/image/section4/10.webp)

Существует два типа пар дочерних ключей: усиленные пары и обычные пары. Процесс получения дочерних ключей использует публичные ключи для генерации условий расходования, в то время как приватные ключи используются для подписи. Расширенный публичный ключ позволяет получать только обычные дочерние публичные ключи, в то время как расширенный приватный ключ позволяет получать все дочерние ключи, как публичные, так и приватные, в обычном или усиленном режиме.

![image](assets/image/section4/11.webp)
![image](assets/image/section4/12.webp)

Усиленный вывод использует родительский приватный ключ, в то время как обычный вывод использует родительский публичный ключ. Функция HMAC-SHA512 используется для усиленного вывода, в то время как для обычной производной используется 512-битный дайджест. Дочерний публичный ключ получается умножением дочернего приватного ключа на генератор эллиптической кривой.

![image](assets/image/section4/13.webp)
![image](assets/image/section4/14.webp)

Иерархическое получение и детерминированное получение множества пар ключей позволяет создавать структуру дерева для иерархического вывода. В следующем уроке этого обучения мы изучим структуру HD кошелька, а также пути вывода, с особым вниманием к обозначениям путей вывода.

## Структура кошелька и пути вывода

<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

В этой главе мы изучим структуру дерева вывода в Иерархическом Детерминированном Кошельке (HD Wallet). Мы уже изучили вычисление сида, мастер-ключа и вывод дочерних пар ключей. Теперь мы сосредоточимся на организации ключей внутри кошелька.

HD кошелек использует слои глубины для организации ключей. Каждый вывод дочерней пары из родительской пары соответствует слою глубины.

![image](assets/image/section4/15.webp)

- Глубина 0 соответствует мастер-ключу и мастер-коду цепи.

- Глубина 1 используется для получения дочерних ключей для конкретной цели, определяемой индексом. Цели соответствуют стандартам BIP 84 и Segwit v0/v1.

- Глубина 2 позволяет различать счета для разных криптовалют или сетей. Это позволяет организовывать кошелек на основе разных источников средств. Для биткойна индекс будет 0.

- Глубина 3 используется для организации кошелька на разные счета, обеспечивая более четкую и организованную структуру.

- Глубина 4 соответствует внешним и внутренним цепям, которые используются для адресов, предназначенных для публичного взаимодействия. Индекс 0 ассоциируется с внешней цепью, в то время как индекс 1 ассоциируется с внутренней цепью. Каждый счет имеет две цепи: внешнюю цепь (0) и внутреннюю цепь (1). Глубина 4 также используется для управления типами скриптов в случае кошельков с мультиподписью.

- Глубина 5 используется для получающих адресов в стандартном кошельке. В следующем разделе мы подробнее рассмотрим получение дочерних пар ключей.

![image](assets/image/section4/16.webp)

Для каждого слоя глубины мы используем индексы для различения дочерних пар ключей.
Индекс без апострофа соответствует фактически используемому индексу, в то время как индекс с апострофом соответствует фактическому индексу + $2^{31}$. Усиленные выводы используют индексы от $2^{31}$ до $2^{32}-1$. Например, индекс 44' соответствует фактическому индексу $2^{31} + 44$.

Для генерации конкретного адреса получения мы выводим дочернюю пару ключей из мастер-ключа и мастер-кода цепи. Затем мы используем индекс для различения разных дочерних пар ключей на одном и той и той же глубине.

Расширенные ключи, такие как XPUB, позволяют вам делиться вашим кошельком с несколькими людьми. Путь вывода используется для различения внешней цепи (адреса, предназначенные для общего доступа) и внутренней цепи (адреса для остатка средств).

В следующей главе мы изучим адреса получения, их преимущества использования и этапы их создания.

# Что такое биткойн-адрес?

<partId>81ec8d17-f8ee-5aeb-8035-d370866f4281</partId>

## Биткойн-адреса

<chapterId>0a887ed8-3424-5a52-98e1-e4b406150475</chapterId>

В этой главе мы рассмотрим адреса получения, которые играют ключевую роль в системе Биткойна. Они позволяют получать средства в транзакции и генерируются из пар приватных и публичных ключей. Хотя существует тип скрипта под названием Pay2PublicKey, который позволяет блокировать биткойны на публичном ключе, пользователи обычно предпочитают использовать адреса получения вместо этого скрипта.

![image](assets/image/section5/0.webp)

Когда получатель хочет получить биткойны, он предоставляет адрес получения отправителю вместо своего публичного ключа. Адрес на самом деле является хешем публичного ключа с определенным форматом. Публичный ключ выводится из дочернего частного ключа с использованием математических операций, таких как сложение и удвоение точек на эллиптических кривых.

![image](assets/image/section5/1.webp)

Важно отметить, что невозможно обратить процесс ни от адреса к публичному ключу, ни от публичного ключа к частному ключу. Использование адреса уменьшает размер информации о публичном ключе, который изначально составляет 512 бит.

Биткойн-адреса были уменьшены в размере для упрощения их использования. У них есть контрольная сумма, которая позволяет обнаруживать опечатки и снижать риск потери биткойнов. С другой стороны, публичные ключи не имеют контрольной суммы, что означает, что опечатки могут привести к потере соответствующих средств.

Адреса также обеспечивают второй уровень безопасности между публичной и частной информацией, делая более сложным контроль над частным ключом.

Существенно подчеркнуть, что каждый адрес должен использоваться только один раз. Повторное использование того же адреса создает проблемы с конфиденциальностью, поэтому рекомендуется это избегать.

Для Биткойн-адресов используются разные префиксы. Например, BC1Q соответствует адресу Segwit V0, BC1P - адресу Taproot/Segwit V1, а префиксы 1 и 3 ассоциируются с адресами Pay2PublicKeyH/Pay2ScriptH (устаревшие). В следующем уроке мы пошагово объясним, как получить адрес из публичного ключа.

## Как создать биткойн-адрес?

<chapterId>6dee7bf3-7767-5f8d-a01b-659b95cfe0a5</chapterId>

В этой главе мы обсудим создание адреса для получения биткойн-транзакций. Адрес получения - это буквенно-цифровое представление сжатого публичного ключа. Преобразование публичного ключа в адрес получения включает несколько шагов.

### Шаг 1: Сжатие публичного ключа

![image](assets/image/section5/14.webp)

Адрес производится из дочернего публичного ключа.

Публичный ключ является точкой на эллиптической кривой. Благодаря симметрии эллиптической кривой, точка на эллиптической кривой будет иметь координату x, связанную только с двумя возможными значениями для y: положительным или отрицательным.
Однако, в протоколе Биткойн мы работаем с конечным набором положительных целых чисел, а не с набором действительных чисел. Чтобы отличить два возможных значения y достаточно указать, четное y или нечетное.

Сжатие публичного ключа уменьшает его размер с 520 бит до 264 бит.

Мы используем префикс 0x02 для четного y и 0x03 для нечетного y. Это сжатая форма публичного ключа.

### Шаг 2: Хэширование сжатого публичного ключа

![image](assets/image/section5/3.webp)

Хэширование сжатого публичного ключа выполняется с использованием функции SHA256. Затем к полученному результату применяется функция RIPEMD160.

### Шаг 3: Полезная нагрузка = Адресная полезная нагрузка

![image](assets/image/section5/4.webp)

Бинарный результат RIPEMD160(SHA256(K)) используется для формирования групп по 5 бит. Каждая группа преобразуется в базе 16 (шестнадцатеричную) и/или базе 10 (десятиричную).

### Шаг 4: Добавление метаданных для расчета контрольной суммы с программой BCH

![image](assets/image/section5/5.webp)

В случае устаревших адресов мы используем двойное хэширование SHA256 для генерации контрольной суммы адреса. Однако для адресов Segwit V0 и V1 мы полагаемся на технологию контрольной суммы BCH для обнаружения ошибок. Программа BCH способна предлагать и исправлять ошибки с чрезвычайно низкой вероятностью ошибок. В настоящее время программа BCH используется для обнаружения и предложения изменений, но она не выполняет их автоматически от имени пользователя.

Программа BCH требует несколько входных данных, включая HRP (Human Readable Part), которую необходимо расширить. Расширение HRP включает кодирование каждой буквы в двоичной системе согласно их ASCII-коду. Затем, берет первые 3 бита результата для каждой буквы и преобразует их в 10-ричную форму (на изображении в синем цвете). После этого добавляет разделитель 0. Затем конкатенирует следующие 5 бит каждой буквы, ранее преобразованной в 10-ричную форму (на изображении в желтом цвете).

Расширение HRP в базе 10 позволяет изолировать последние пять бит каждого символа, тем самым усиливая контрольную сумму.

Версия Segwit V0 представлена кодом 00, а "полезная нагрузка" находится в черном цвете, в базе 10. За этим следуют шесть зарезервированных символов для контрольной суммы.

### Шаг 5: Расчет контрольной суммы с программой BCH

![image](assets/image/section5/6.webp)

Ввод, содержащий метаданные, затем подается в программу BCH для получения контрольной суммы в базе 10.

Здесь у нас контрольная сумма.

### Шаг 6: Конструирование адреса и преобразование в Bech32

![image](assets/image/section5/7.webp)

Конкатенация версии, полезной нагрузки и контрольной суммы позволяет построить адрес. Символы базы 10 затем преобразуются в символы Bech32 с использованием таблицы соответствия. Алфавит Bech32 включает все буквенно-цифровые символы, кроме 1, b, i и o, чтобы избежать любой путаницы.

### Шаг 7: Добавление HRP и разделителя

![image](assets/image/section5/8.webp)

На изображении в розовом цвете контрольная сумма.
В черном цвете полезная нагрузка = хеш публичного ключа.
В синем цвете версия.

Все преобразуется в Bech32, затем добавляется 'bc' для биткойна и '1' в качестве разделителя, и вот так получается адрес.

# Идем дальше

<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## Создание сида из 128 бросков кубика!

<chapterId>0f4d40a7-cf0e-5faf-bc4d-691486771ac1</chapterId>

Создание мнемонической фразы является ключевым шагом в обеспечении безопасности вашего криптовалютного кошелька. Существует несколько методов генерации мнемонической фразы, однако мы сосредоточимся на ручном методе генерации с использованием кубиков. Важно отметить, что этот метод не подходит для кошелька с высокой стоимостью. Рекомендуется использовать программное обеспечение с открытым исходным кодом или аппаратный кошелек для генерации мнемонической фразы. Для создания мнемонической фразы мы будем использовать кубики для генерации бинарной информации. Цель - понять процесс создания мнемонической фразы.

**Шаг 1 - Подготовка:**
Убедитесь, что у вас установлен амнезический дистрибутив Linux, такой как Tails OS, на USB-ключе для дополнительной безопасности. Обратите внимание, что это руководство не следует использовать для создания основного кошелька.

**Шаг 2 - Генерация случайного бинарного числа:**
Мы будем использовать кубик для генерации бинарной информации. Бросьте кубик 128 раз и записывайте каждый результат (1 для нечетного, 0 для четного).

**Шаг 3 - Организация бинарных чисел:**
Организуйте полученные бинарные числа в строки по 11 цифр для упрощения дальнейших расчетов. В двенадцатой строке должно быть только 7 цифр.

**Шаг 4 - Расчет контрольной суммы:**
Последние 4 цифры для двенадцатой строки соответствуют контрольной сумме. Для расчета этой контрольной суммы нам нужно использовать терминал из дистрибутива Linux. Рекомендуется использовать [TailOs](https://tails.boum.org/index.fr.html), который является загрузочным дистрибутивом без сохранения данных с USB-ключа. В вашем терминале, введите команду `echo <binary number> | shasum -a 254 -0`. Замените `<binary number>` на ваш список из 128 нулей и единиц. Результатом будет шестнадцатеричный хеш. Запишите первый символ этого хеша и преобразуйте его в бинарный. Вы можете использовать эту [таблицу](https://www.educative.io/answers/decimal-binary-and-hex-conversion-table) для помощи. Добавьте бинарную контрольную сумму (4 цифры) к двенадцатой строке вашего листа.

**Шаг 5 - Преобразование в десятичное число:**
Чтобы найти слова, связанные с каждой из ваших строк, вам сначала нужно преобразовать каждую серию из 11 бит в десятичное число. Здесь вы не можете использовать онлайн-конвертер, поскольку эти биты представляют вашу мнемоническую фразу. Поэтому вам нужно будет преобразовать их с помощью калькулятора и трюка следующим образом: каждый бит ассоциируется со степенью двойки, так что слева направо у нас есть 11 рангов, соответствующих 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1. Чтобы преобразовать вашу серию из 11 бит в десятичное число, просто сложите только те ранги, которые содержат 1. Например, для серии 00110111011 это соответствует следующему сложению: 256 + 128 + 32 + 16 + 8 + 2 + 1 = 443. Теперь вы можете преобразовать каждую строку в десятичное число. И перед переходом к кодированию в слова добавьте к всем строкам +1, потому что индекс списка слов BIP39 начинается с 1, а не с 0.
**Шаг 8 - Создание мнемонической фразы:**
Начните с распечатки [списка из 2048 слов](https://seedxor.com/files/wordlist.pdf), чтобы преобразовать ваши десятичные числа в слова BIP39. Уникальность этого списка заключается в том, что ни одно слово не делится первыми 4 буквами с любым другим словом в этом словаре. Затем найдите слово, связанное с десятичным числом каждой из ваших строк.
**Шаг 9 - Тест мнемонической фразы:**
Немедленно проверьте вашу мнемоническую фразу в Sparrow Wallet, создав кошелек из неё. Если вы получите ошибку неверной контрольной суммы, скорее всего, вы допустили ошибку в расчетах. Исправьте эту ошибку, вернувшись к шагу 4, и снова протестируйте в Sparrow Wallet. Вуаля! Вы только что создали новый биткойн-кошелек из 128 бросков кости.

Создание мнемонической фразы - важный процесс для обеспечения безопасности вашего криптовалютного кошелька. Рекомендуется использовать более безопасные методы, такие как использование программного обеспечения с открытым исходным кодом или аппаратного кошелька, для генерации мнемонической фразы. Однако выполнение этого мастер-класса помогает лучше понять, как мы можем создать Биткойн-кошелек из случайного числа.

## БОНУС: Интервью с Тео Пантамисом

<chapterId>39f0ec5a-e258-55cb-9789-bc46d314d816</chapterId>

Еще один широко используемый криптографический метод в протоколе Биткойн - метод цифровых подписей.

![видео](https://youtu.be/c9MvtGJsEvY?si=bQ1N5NCd6op0G6nW)


## Оцените курс
<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>
<isCourseReview>true</isCourseReview>

## Выпускной экзамен
<chapterId>a53ea27d-0f84-56cd-b37c-a66210a4b31d</chapterId>
<isCourseExam>true</isCourseExam>

## Заключение и конец

<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

### Спасибо и продолжайте исследовать кроличью нору

Мы искренне благодарим вас за завершение курса Crypto 301. Мы надеемся, что этот опыт был для вас обогащающим и познавательным. Мы рассмотрели множество захватывающих тем, от математики до криптографии и работы протокола Биткойн.

Если вы хотите углубиться в тему, у нас есть дополнительный ресурс для вас. Мы провели эксклюзивное интервью с Тео Пантамисом и Лоиком Морелем, двумя известными экспертами в области криптографии. Это интервью исследует различные аспекты темы более глубоко и предоставляет интересные перспективы.

Посмотрите это интервью, чтобы продолжить исследование увлекательной области криптографии. Мы надеемся, что оно будет полезным и вдохновляющим в вашем пути. Еще раз спасибо за ваше участие и заинтересованность на протяжении всего курса.

### Поддержите нас

Этот курс, как и весь контент этого университета, предоставлен вам бесплатно нашим сообществом. Чтобы поддержать нас, вы можете поделиться им с другими, стать членом университета и даже внести свой вклад в его развитие через GitHub. От имени всей команды, спасибо!

### Оцените курс

Система оценок для обучения вскоре будет интегрирована в новую платформу электронного обучения! Пока что большое спасибо за прохождение курса, и если он вам понравился, пожалуйста, поделитесь им с другими.
