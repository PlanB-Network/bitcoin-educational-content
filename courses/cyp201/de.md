---
name: Einführung in die kryptographischen Algorithmen von Bitcoin
goal: Verständnis der Erstellung einer Bitcoin-Wallet aus kryptographischer Sicht
objectives:
  - Entmystifizierung der kryptographischen Terminologie im Zusammenhang mit Bitcoin.
  - Beherrschung der Erstellung einer Bitcoin-Wallet.
  - Verständnis der Struktur einer Bitcoin-Wallet.
  - Verständnis von Adressen und Ableitungspfaden.
---

# Eine Reise in die Kryptographie

Sind Sie von Bitcoin fasziniert? Fragen Sie sich, wie eine Bitcoin-Wallet funktioniert? Machen Sie sich bereit für eine fesselnde Reise in die Kryptographie! Unser Experte Loïc wird Sie durch die Feinheiten der Erstellung einer Bitcoin-Wallet führen und die Geheimnisse hinter einschüchternden technischen Begriffen wie Hashing, Schlüsselableitung und elliptischen Kurven enthüllen.

Dieses Training wird Sie nicht nur mit dem Wissen ausstatten, um die Struktur einer Bitcoin-Wallet zu verstehen, sondern Sie auch darauf vorbereiten, tiefer in die aufregende Welt der Kryptographie einzutauchen. Sind Sie bereit, sich auf diese Reise zu begeben? Begleiten Sie uns und verwandeln Sie Ihre Neugier in Expertise!

+++

# Einführung
<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## Einführung in die Kryptographie
<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

### Ist dieses Training für Sie geeignet? JA!

Wir freuen uns, Sie zu dem neuen Schulungskurs "Crypto 301: Einführung in die Kryptographie und HD-Wallet" begrüßen zu dürfen, der von dem Experten auf diesem Gebiet, Loïc Morel, geleitet wird. Dieser Kurs wird Sie in die faszinierende Welt der Kryptographie eintauchen lassen, der grundlegenden Disziplin der Mathematik, die die Verschlüsselung und Sicherheit Ihrer Daten gewährleistet.

In unserem täglichen Leben, insbesondere im Bereich von Bitcoin, spielt Kryptographie eine entscheidende Rolle. Konzepte im Zusammenhang mit Kryptographie, wie private Schlüssel, öffentliche Schlüssel, Adressen, Ableitungspfade, Seed und Entropie, stehen im Mittelpunkt der Verwendung und Erstellung einer Bitcoin-Wallet. Im Laufe dieses Kurses wird Loïc ausführlich erklären, wie private Schlüssel generiert werden und wie sie mit Adressen verknüpft sind. Loïc wird auch eine Stunde damit verbringen, die mathematischen Details elliptischer Kurven zu erklären. Darüber hinaus werden Sie verstehen, warum die Verwendung von HMAC SHA512 für die Sicherheit Ihrer Wallet wichtig ist und was der Unterschied zwischen einem Seed und einer mnemonischen Phrase ist.

Das ultimative Ziel dieses Trainings ist es, Ihnen das Verständnis der technischen Prozesse bei der Erstellung einer HD-Wallet und der verwendeten kryptographischen Methoden zu ermöglichen. Im Laufe der Jahre haben sich Bitcoin-Wallets weiterentwickelt, um einfacher zu bedienen, sicherer und standardisierter zu sein, dank spezifischer BIPs. Loïc wird Ihnen helfen, diese BIPs zu verstehen, um die Entscheidungen der Bitcoin-Entwickler und Kryptographen zu erfassen. Wie alle von unserer Universität angebotenen Schulungen ist auch diese völlig kostenlos und Open Source. Das bedeutet, dass Sie sie frei nutzen und verwenden können, wie Sie möchten. Wir freuen uns darauf, Ihr Feedback am Ende dieses aufregenden Kurses zu erhalten.

### Das Wort hat der Professor!

Hallo allerseits, ich bin Loïc Morel, Ihr Führer durch diese technische Erkundung der Kryptographie, die in Bitcoin-Wallets verwendet wird.

Unsere Reise beginnt mit einem Tauchgang in die Tiefen kryptographischer Hash-Funktionen. Gemeinsam werden wir die Funktionsweise des unverzichtbaren SHA256 analysieren und verschiedene Algorithmen zur Ableitung erkunden.

Wir werden unser Abenteuer fortsetzen, indem wir die geheimnisvolle Welt der digitalen Signaturen entschlüsseln. Sie werden entdecken, wie die Magie elliptischer Kurven auf diese Signaturen angewendet wird, und wir werden Licht ins Dunkel bringen, wie der öffentliche Schlüssel aus dem privaten Schlüssel berechnet wird. Und natürlich werden wir uns mit dem Prozess der digitalen Signatur befassen.
Als erfahrener professioneller Übersetzer liegt Ihre Hauptaufgabe darin, technische Inhalte aus dem Englischen präzise in Ihre Muttersprache, Deutsch, zu übersetzen. Bitte beachten Sie die folgenden Richtlinien, um eine hochwertige Übersetzung sicherzustellen:

Ursprungssprache: Der Inhalt liegt ursprünglich auf Englisch vor.

Art des Inhalts: Sie werden auf technisches Material stoßen, möglicherweise einschließlich branchenspezifischer Terminologie.
Links und technische Begriffe: Übersetzen Sie keine URLs oder hochspezifischen technischen Begriffe. Wenn Sie unsicher sind, behalten Sie den Originalbegriff bei.
Formatierungskonsistenz: Beibehaltung des gleichen Markdown-Layouts und der Formatierung wie im Originaltext. Die Konsistenz der Struktur ist entscheidend.
YML-Eigenschaften: Wenn eine Zeile mit einer YAML-Eigenschaft beginnt (z. B. 'name:', 'goal:', 'objectives:'), behalten Sie den Eigenschaftsnamen in Englisch bei.
Kultureller Kontext: Bei kulturellen oder kontextspezifischen Verweisen, die möglicherweise nicht direkt übersetzt werden können, umschreiben Sie diese, um die beabsichtigte Bedeutung zu erhalten, oder geben Sie eine kurze Erklärung.
Der Schwerpunkt sollte darauf liegen, die Integrität des technischen Inhalts zu wahren und gleichzeitig sicherzustellen, dass die Übersetzung in Deutsch verständlich und kontextuell korrekt ist.

Als Nächstes werden wir in die Vergangenheit zurückreisen, um die Entwicklung von Bitcoin-Wallets zu sehen, und wir werden uns mit den Konzepten von Entropie und Zufallszahlen befassen. Wir werden uns die berühmte mnemonische Phrase ansehen und auch auf die Passphrase eingehen. Sie haben sogar die Möglichkeit, etwas Einzigartiges zu erleben, indem Sie einen Seed aus 128 Würfelwürfen erstellen!

Mit diesen soliden Grundlagen werden wir bereit sein für den entscheidenden Teil: die Erstellung einer Bitcoin-Wallet. Vom Entstehen des Seeds und des Master Keys über das Studium der erweiterten Schlüssel bis hin zur Ableitung von Kinderschlüsselpaaren wird jeder Schritt analysiert. Wir werden auch die Struktur der Wallet und die Ableitungspfade besprechen.

Zu guter Letzt werden wir unsere Reise abschließen, indem wir Bitcoin-Adressen untersuchen. Wir werden erklären, wie sie erstellt werden und welche wesentliche Rolle sie für die Funktionsweise von Bitcoin-Wallets spielen.

Begleiten Sie mich auf dieser fesselnden Reise und machen Sie sich bereit, die Welt der Kryptographie wie nie zuvor zu erkunden. Lassen Sie Ihre vorgefassten Meinungen hinter sich und öffnen Sie Ihren Geist für eine neue Art, Bitcoin und seine grundlegende Struktur zu verstehen.

# Hash-Funktionen
<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## Einführung in kryptographische Hash-Funktionen im Zusammenhang mit Bitcoin
<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

Willkommen zur heutigen Sitzung, die ganz der tiefen Eintauchen in die kryptographische Welt der Hash-Funktionen gewidmet ist, einem entscheidenden Eckpfeiler der Sicherheit des Bitcoin-Protokolls. Stellen Sie sich eine Hash-Funktion als einen ultraleistungsfähigen kryptographischen Entschlüsselungsroboter vor, der Informationen beliebiger Größe in einen eindeutigen und festen digitalen Fingerabdruck, genannt "Hash", "Digest" oder "Checksum", umwandelt.
Zusammenfassend nimmt eine Hash-Funktion eine Eingabebotschaft beliebiger Größe entgegen und wandelt sie in einen festen Ausgabefingerabdruck um.

Die Beschreibung des Profils kryptographischer Hash-Funktionen erfordert das Verständnis zweier wesentlicher Eigenschaften: ihrer Unumkehrbarkeit und ihrer Fälschungssicherheit.

Unumkehrbarkeit oder Widerstandsfähigkeit gegen Preimage bedeutet, dass die Berechnung der Ausgabe anhand der Eingabe leicht durchgeführt werden kann, die Berechnung der Eingabe anhand der Ausgabe jedoch unmöglich ist.
Es handelt sich um eine Einwegfunktion.

![Bild](assets/image/section1/0.webp)

Die Fälschungssicherheit ergibt sich daraus, dass bereits die geringste Änderung der Eingabe zu einer grundlegend anderen Ausgabe führt.
Diese Funktionen ermöglichen die Überprüfung der Integrität von heruntergeladener Software.

![Bild](assets/image/section1/1.webp)

Eine weitere entscheidende Eigenschaft, die sie besitzen, ist ihre Widerstandsfähigkeit gegen Kollisionen und zweite Preimages. Eine Kollision tritt auf, wenn zwei unterschiedliche Eingaben die gleiche Ausgabe erzeugen.

In der Welt der Hash-Funktionen sind Kollisionen sicherlich unvermeidlich, aber eine ausgezeichnete kryptographische Hash-Funktion minimiert sie erheblich. Das Risiko muss so gering sein, dass es als vernachlässigbar angesehen werden kann. Es ist, als ob jeder Hash ein Haus in einer riesigen Stadt wäre; trotz der enormen Anzahl von Häusern stellt eine gute Hash-Funktion sicher, dass jedes Haus eine eindeutige Adresse hat.
Die Widerstandsfähigkeit gegen zweite Preimages hängt von der Widerstandsfähigkeit gegen Kollisionen ab; wenn es Widerstand gegen Kollisionen gibt, dann gibt es auch Widerstand gegen zweite Preimages.

Gegeben eine uns auferlegte Eingabeinformation, müssen wir eine zweite Eingabe finden, die sich von der ersten unterscheidet und eine Kollision im Ausgabe-Hash der Funktion erzeugt. Die Widerstandsfähigkeit gegen zweite Preimages ähnelt der Widerstandsfähigkeit gegen Kollisionen, mit dem Unterschied, dass die Eingabe vorgegeben ist.
Lassen Sie uns nun die stürmischen Gewässer veralteter Hash-Funktionen befahren. SHA0, SHA1 und MD5 gelten heute als verrostete Schalen im Ozean der kryptographischen Hash-Funktionen. Sie werden oft abgeraten, da sie ihre Widerstandsfähigkeit gegen Kollisionen verloren haben. Das Schubfachprinzip erklärt, warum trotz unserer besten Bemühungen die Vermeidung von Kollisionen aufgrund der Begrenzung der Ausgabegröße unmöglich ist. Um als wirklich sicher zu gelten, muss eine Hash-Funktion Kollisionen, zweite Preimages und Preimages widerstehen.
Ein Schlüsselelement im Bitcoin-Protokoll ist die SHA-256-Hashfunktion, die das Schiff steuert. Andere Funktionen wie SHA-512 werden zur Ableitung mit HMAC und PBKDF verwendet. Zusätzlich wird RIPMD160 verwendet, um einen Fingerabdruck auf 160 Bits zu reduzieren. Wenn wir von HASH256 und HASH160 sprechen, beziehen wir uns auf die Verwendung von doppeltem Hashing mit SHA-256 und RIPMD.

Bei HASH256 handelt es sich um einen doppelten Hash der Nachricht unter Verwendung der SHA256-Funktion.
$$
SHA256(SHA256(Nachricht))
$$
Bei HASH160 handelt es sich um einen doppelten Hash der Nachricht, wobei zuerst SHA256 und dann RIPMD160 verwendet werden.
$$
RIPMD160(SHA256(Nachricht))
$$
Die Verwendung von HASH160 ist besonders vorteilhaft, da sie die Sicherheit von SHA-256 gewährleistet und gleichzeitig die Größe des Fingerabdrucks reduziert.

Zusammenfassend ist das ultimative Ziel einer kryptografischen Hashfunktion die Umwandlung von beliebig großen Informationen in einen Fingerabdruck fester Größe. Um als sicher anerkannt zu werden, muss sie mehrere Stärken aufweisen: Unumkehrbarkeit, Widerstandsfähigkeit gegen Manipulation, Widerstandsfähigkeit gegen Kollisionen und Widerstandsfähigkeit gegen zweite Vorbilder.

Am Ende dieser Erkundung haben wir kryptografische Hashfunktionen entmystifiziert, ihre Verwendung im Bitcoin-Protokoll hervorgehoben und ihre spezifischen Ziele analysiert. Wir haben gelernt, dass Hashfunktionen, um als sicher angesehen zu werden, widerstandsfähig gegen Vorbilder, zweite Vorbilder, Kollisionen und Manipulation sein müssen. Wir haben auch die verschiedenen Hashfunktionen behandelt, die im Bitcoin-Protokoll verwendet werden. In unserer nächsten Sitzung werden wir uns mit dem Kern der SHA256-Hashfunktion befassen und die faszinierende Mathematik entdecken, die ihr ihre einzigartigen Eigenschaften verleiht.

## Die Funktionsweise von SHA256
<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>

Willkommen zur Fortsetzung unserer faszinierenden Reise durch die kryptografischen Irrgärten der Hashfunktion. Heute enthüllen wir die Geheimnisse von SHA256, einem komplexen, aber genialen Prozess, den wir zuvor vorgestellt haben.
-> 940 + 1 + P + 64 = 1024-> P = 1024 - 1 - 64 - 950
-> P = 9

Daher müssen 9 Auffüllbits hinzugefügt werden, um eine Nachricht auf ein Vielfaches von 512 zu bringen.

Und jetzt?
Direkt nach der ursprünglichen Nachricht muss der Trenner 1 gefolgt von P hinzugefügt werden, der in unserem Beispiel neun 0en ist.

```
Nachricht + 1 000 000 000
```

#### Größenanpassung

Wir gehen nun zur zweiten Phase der Vorverarbeitung über, bei der die binäre Darstellung der Größe der ursprünglichen Nachricht in Bits hinzugefügt wird.

Schauen wir uns das Beispiel mit einer Eingabe von 950 Bits noch einmal an:

Die binäre Darstellung der Zahl 950 lautet: 11 1011 0110

Wir verwenden unsere 64 reservierten Bits aus dem vorherigen Schritt. Wir fügen Nullen hinzu, um unsere 64 Bits auf unsere angeglichene Eingabe abzurunden. Dann verbinden wir die ursprüngliche Nachricht, die Auffüllbits und die Größenanpassung, um unsere angeglichene Eingabe zu erhalten.

Hier ist das Ergebnis:

![image](assets/image/section1/4.webp)

### Verarbeitung

#### Verständnis der Voraussetzungen

##### Konstanten und Initialisierungsvektoren

Jetzt bereiten wir uns auf die ersten Schritte der Verarbeitung der SHA-256-Funktion vor. Wie bei jedem guten Rezept benötigen wir einige grundlegende Zutaten, die wir Konstanten und Initialisierungsvektoren nennen.

Die Initialisierungsvektoren von A bis H sind die ersten 32 Bits der Dezimalteile der Quadratwurzeln der ersten 8 Primzahlen. Sie dienen als Basiswerte in den ersten Verarbeitungsschritten. Ihre Werte sind im hexadezimalen Format.

Die Konstanten K von 0 bis 63 repräsentieren die ersten 32 Bits der Dezimalteile der Kubikwurzeln der ersten 64 Primzahlen. Sie werden in jeder Runde der Kompressionsfunktion verwendet. Ihre Werte sind ebenfalls im hexadezimalen Format.

![image](assets/image/section1/5.webp)

##### Verwendete Operationen

Innerhalb der Kompressionsfunktion verwenden wir spezifische Operatoren wie XOR, AND und NOT. Wir verarbeiten die Bits einzeln entsprechend ihrer Position unter Verwendung des XOR-Operators und einer Wahrheitstabelle. Der AND-Operator wird verwendet, um 1 zurückzugeben, nur wenn beide Operanden gleich 1 sind, und der NOT-Operator wird verwendet, um den entgegengesetzten Wert eines Operanden zurückzugeben. Wir verwenden auch die SHR-Operation, um die Bits um eine gewählte Anzahl nach rechts zu verschieben.

Die Wahrheitstabelle:

![image](assets/image/section1/6.webp)

Bit-Verschiebungsoperationen:

![image](assets/image/section1/7.webp)

#### Die Kompressionsfunktion

Bevor wir die Kompressionsfunktion anwenden, teilen wir die Eingabe in Blöcke von 512 Bits auf. Jeder Block wird unabhängig von den anderen verarbeitet.

Jeder 512-Bit-Block wird dann weiter in 32-Bit-Chunks namens W unterteilt. Auf diese Weise repräsentiert W(0) die ersten 32 Bits des 512-Bit-Blocks. W(1) repräsentiert die nächsten 32 Bits und so weiter, bis wir die 512 Bits des Blocks erreichen.

Sobald alle Konstanten K und die Chunks W definiert sind, können wir für jeden Chunk W in jeder Runde die folgenden Berechnungen durchführen.

Wir führen 64 Runden von Berechnungen in der Kompressionsfunktion durch. In der letzten Runde, auf der Ebene "Ausgabe der Funktion", haben wir einen Zwischenzustand, der zum anfänglichen Zustand der Kompressionsfunktion hinzugefügt wird.

Dann wiederholen wir all diese Schritte der Kompressionsfunktion auf dem nächsten 512-Bit-Block, bis zum letzten Block.
Alle Additionen in der Kompressionsfunktion sind Modulo-2^32-Additionen, um immer eine 32-Bit-Summe zu erhalten.

![image](assets/image/section1/9.webp)

![image](assets/image/section1/8.webp)

##### Ein Durchlauf der Kompressionsfunktion

![image](assets/image/section1/11.webp)

![image](assets/image/section1/10.webp)

Die Kompressionsfunktion wird 64 Mal durchgeführt. Wir haben unsere Teile W und unsere zuvor definierten Konstanten K als Eingabe.
Die roten Quadrate/Kreuze entsprechen einer Modulo-2^32-Bit-Addition.

Die Eingaben A, B, C, D, E, F, G, H werden mit einem 32-Bit-Wert assoziiert, um insgesamt 32 * 8 = 256 Bits zu ergeben.
Wir haben auch eine neue Sequenz A, B, C, D, E, F, G, H als Ausgabe. Diese Ausgabe wird dann als Eingabe für den nächsten Durchlauf verwendet und so weiter bis zum Ende des 64. Durchlaufs.

Die Werte der Eingabesequenz für den ersten Durchlauf der Kompressionsfunktion entsprechen den zuvor definierten Initialisierungsvektoren.
Als Erinnerung: Die Initialisierungsvektoren repräsentieren die ersten 32 Bits der Dezimalteile der Quadratwurzeln der ersten 8 Primzahlen.

Hier ist ein Beispiel für einen Durchlauf:

![image](assets/image/section1/12.1.webp)

##### Zwischenzustand

Als Erinnerung: Die Nachricht wird in Blöcke von 512 Bits aufgeteilt, die dann in 32-Bit-Stücke aufgeteilt werden. Für jeden 512-Bit-Block wenden wir die 64 Durchläufe der Kompressionsfunktion an.
Der Zwischenzustand entspricht dem Ende der 64 Durchläufe eines Blocks. Die Werte der Ausgabesequenz aus diesem 64. Durchlauf werden als Anfangswerte für die Eingabesequenz des ersten Durchlaufs des nächsten Blocks verwendet.

![image](assets/image/section1/12.2.webp)

#### Überblick über die Hash-Funktion

![image](assets/image/section1/13.webp)

Wir können feststellen, dass die Ausgabe des ersten 512-Bit-Nachrichtenstücks unseren Initialisierungsvektoren als Eingabe für das zweite 512-Bit-Nachrichtenstück entspricht und so weiter.

Die Ausgabe des letzten Durchlaufs, des letzten Stücks, entspricht dem endgültigen Ergebnis der SHA256-Funktion.

Abschließend möchten wir die entscheidende Rolle der Berechnungen in den CH-, MAJ-, σ0- und σ1-Boxen betonen. Diese Operationen sind unter anderem die Wächter, die die Robustheit der SHA256-Hash-Funktion gegen Angriffe gewährleisten und sie zu einer bevorzugten Wahl zur Sicherung vieler digitaler Systeme machen, insbesondere innerhalb des Bitcoin-Protokolls. Es ist offensichtlich, dass die Schönheit von SHA256, obwohl komplex, in ihrer Fähigkeit liegt, die Eingabe aus dem Hash zu finden, während die Überprüfung des Hash für eine gegebene Eingabe eine mechanisch einfache Aktion ist.

## Die für die Ableitung verwendeten Algorithmen
<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>

Die HMAC- und PBKDF2-Ableitungsalgorithmen sind Schlüsselkomponenten im Sicherheitsmechanismus des Bitcoin-Protokolls. Sie verhindern verschiedene potenzielle Angriffe und gewährleisten die Integrität von Bitcoin-Wallets.
HMAC und PBKDF2 sind kryptografische Werkzeuge, die für verschiedene Aufgaben in Bitcoin verwendet werden. HMAC wird hauptsächlich verwendet, um Längenerweiterungsangriffe bei der Ableitung von hierarchisch deterministischen (HD) Wallets zu bekämpfen, während PBKDF2 verwendet wird, um eine mnemonische Phrase in einen Seed umzuwandeln.

#### HMAC-SHA512

Das HMAC-SHA512-Paar hat zwei Eingaben: eine Nachricht m (Eingabe 1) und einen vom Benutzer beliebig gewählten Schlüssel K (Eingabe 2). Es hat auch eine Ausgabe fester Größe: 512 Bits.

Lasst uns festhalten:
- m: vom Benutzer gewählte Nachricht beliebiger Größe (Eingabe 1)
- K: vom Benutzer gewählter beliebiger Schlüssel (Eingabe 2)
- K': angepasster Schlüssel K. Er wurde an die Größe B der Blöcke angepasst.
- ||: Verkettungsoperation.
- opad: Konstante definiert durch das Byte 0x5c, wiederholt B Mal.
- ipad: Konstante definiert durch das Byte 0x36, wiederholt B Mal.
- B: Die Größe der Blöcke der verwendeten Hashfunktion.

HMAC-SHA512, das eine Nachricht und einen Schlüssel als Eingabe erhält, erzeugt eine Ausgabe fester Größe. Um die Einheitlichkeit zu gewährleisten, wird der Schlüssel entsprechend der Größe der in der Hashfunktion verwendeten Blöcke angepasst. Im Kontext der HD-Wallet-Derivation wird HMAC-SHA-512 verwendet. Es arbeitet mit 1024-Bit (128-Byte) Blöcken und passt den Schlüssel entsprechend an. Es verwendet die Konstanten OPAD (0x5c) und IPAD (0x36), die bei Bedarf wiederholt werden, um die Sicherheit zu erhöhen.

Der HMAC-SHA-512-Prozess beinhaltet die Verkettung des Ergebnisses von SHA-512, das auf den Schlüssel XOR OPAD angewendet wird, und des Schlüssels XOR IPAD mit der Nachricht. Bei Verwendung von 1024-Bit (128-Byte) Blöcken wird der Eingabeschlüssel bei Bedarf mit Nullen aufgefüllt und dann mit IPAD und OPAD XOR-verknüpft. Der modifizierte Schlüssel wird dann mit der Nachricht verkettet.

Die Verwendung eines Salzes im Zeichenfolgencode erhöht die Sicherheit der abgeleiteten Schlüssel. Ohne Salz könnte ein Angriff die gesamte Brieftasche gefährden und alle Bitcoins stehlen.

PBKDF2 wird verwendet, um eine mnemonische Phrase in einen Seed umzuwandeln. Dieser Algorithmus führt 2048 Runden mit HMAC SHA512 durch. Durch diese Ableitungsalgorithmen können verschiedene Eingaben eine eindeutige und feste Ausgabe erzeugen, was das Problem möglicher Längenerweiterungsangriffe auf SHA-2-Familienfunktionen mildert.
Ein Längenerweiterungsangriff nutzt eine spezifische Eigenschaft bestimmter kryptografischer Hashfunktionen aus. Bei einem solchen Angriff kann ein Angreifer, der bereits den Hash einer unbekannten Nachricht besitzt, diesen verwenden, um den Hash einer längeren Nachricht zu berechnen, die eine Erweiterung der ursprünglichen Nachricht ist. Dies ist oft möglich, ohne den Inhalt der ursprünglichen Nachricht zu kennen, was zu erheblichen Sicherheitslücken führen kann, wenn diese Art von Hashfunktion für Aufgaben wie Integritätsprüfung verwendet wird.

Zusammenfassend spielen die HMAC- und PBKDF2-Algorithmen eine wesentliche Rolle bei der Sicherheit der HD-Wallet-Derivation im Bitcoin-Protokoll. HMAC-SHA-512 wird verwendet, um Längenerweiterungsangriffe zu verhindern, während PBKDF2 die Umwandlung der mnemonischen Phrase in einen Seed ermöglicht. Der Zeichenfolgencode fügt der Schlüsselableitung eine zusätzliche Entropiequelle hinzu und gewährleistet die Robustheit des Systems.

# Digitale Signaturen
<partId>76b58a00-0c18-54b9-870d-6b7e34029db8</partId>

## Digitale Signaturen und elliptische Kurven
<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

Wo werden diese berühmten Bitcoins gespeichert? Nicht in einer Bitcoin-Brieftasche, wie man vielleicht denken würde. Tatsächlich speichert eine Bitcoin-Brieftasche die privaten Schlüssel, die zum Nachweis des Eigentums an den Bitcoins erforderlich sind. Die Bitcoins selbst werden auf der Blockchain, einer dezentralen Datenbank, die alle Transaktionen archiviert, erfasst.

Im Bitcoin-System ist die Einheit der Rechnungseinheit der Bitcoin (beachten Sie das kleine "b"). Sie ist bis zu acht Dezimalstellen teilbar, wobei die kleinste Einheit der Satoshi ist. UTXOs oder "Unspent Transaction Outputs" repräsentieren die ungenutzten Transaktionsausgaben, die zu einem öffentlichen Schlüssel gehören, der mathematisch mit einem privaten Schlüssel verknüpft ist. Um diese Bitcoins auszugeben, muss man die Ausgabebedingung der Transaktion erfüllen können. Eine typische Ausgabebedingung besteht darin, dem Rest des Netzwerks nachzuweisen, dass der Benutzer der rechtmäßige Besitzer des öffentlichen Schlüssels ist, der mit dem UTXO verknüpft ist. Dazu muss der Benutzer den Besitz des privaten Schlüssels nachweisen, der dem öffentlichen Schlüssel jedes UTXO entspricht, ohne den privaten Schlüssel preiszugeben.

Hier kommt die digitale Signatur ins Spiel. Sie dient als mathematischer Nachweis des Besitzes eines privaten Schlüssels, der mit einem bestimmten öffentlichen Schlüssel verknüpft ist. Diese Datensicherungstechnik basiert hauptsächlich auf einem faszinierenden Bereich der Kryptographie namens elliptische Kurvenkryptographie (ECC).

Die Signatur kann mathematisch von anderen Teilnehmern im Bitcoin-Netzwerk überprüft werden.

![image](assets/image/section2/0.webp)

Um die Sicherheit von Transaktionen zu gewährleisten, setzt Bitcoin auf zwei digitale Signaturprotokolle: ECDSA (Elliptic Curve Digital Signature Algorithm) und Schnorr. ECDSA ist seit der Einführung von Bitcoin im Jahr 2009 ein Signaturprotokoll, während Schnorr-Signaturen erst kürzlich im November 2021 hinzugefügt wurden. Obwohl beide Protokolle auf elliptischer Kurvenkryptographie basieren und ähnliche mathematische Mechanismen verwenden, unterscheiden sie sich hauptsächlich in Bezug auf die Signaturstruktur.

In diesem Kurs werden wir den ECDSA-Algorithmus vorstellen.

### Was ist eine elliptische Kurve?

Elliptische Kurvenkryptographie ist eine Reihe von Algorithmen, die eine elliptische Kurve für ihre verschiedenen geometrischen und mathematischen Eigenschaften in einem kryptographischen Kontext verwenden, wobei die Sicherheit auf der Schwierigkeit der Berechnung des diskreten Logarithmus beruht.

Elliptische Kurven sind in verschiedenen kryptographischen Anwendungen im Bitcoin-Protokoll nützlich, von Schlüsselaustausch über asymmetrische Verschlüsselung bis hin zu digitalen Signaturen.

Elliptische Kurven haben interessante Eigenschaften:

- Symmetrie: Jede nicht-vertikale Linie, die zwei Punkte auf der elliptischen Kurve schneidet, schneidet die Kurve an einem dritten Punkt.
- Jede nicht-vertikale Linie, die die Kurve in einem Punkt berührt, schneidet die Kurve immer an einem eindeutigen zweiten Punkt.

Das Bitcoin-Protokoll verwendet eine spezifische elliptische Kurve namens Secp256k1 für seine kryptographischen Operationen.

Bevor wir uns tiefer mit diesen Signaturmechanismen befassen, ist es wichtig zu verstehen, was eine elliptische Kurve ist. Eine elliptische Kurve wird durch die Gleichung y² = x³ + ax + b definiert. Jeder Punkt auf dieser Kurve hat eine charakteristische Symmetrie, die für ihre Nützlichkeit in der Kryptographie entscheidend ist.

![image](assets/image/section2/1.webp)

Letztendlich werden verschiedene elliptische Kurven als sicher für kryptographische Zwecke anerkannt. Die bekannteste davon ist möglicherweise die secp256r1-Kurve. Für Bitcoin hat sich Satoshi Nakamoto jedoch für eine andere Kurve entschieden: secp256k1.

Diese Kurve wird durch die Parameter a=0 und b=7 definiert, und ihre Gleichung lautet y² = x³ + 7 modulo n, wobei n die Primzahl ist, die die Ordnung der Kurve bestimmt.

![image](assets/image/section2/2.webp)

Das erste Bild stellt die secp256k1-Kurve über dem reellen Feld und ihrer Gleichung dar.
Das zweite Bild ist eine Darstellung der secp256k1-Kurve über dem Feld ZP, dem Feld der positiven natürlichen Zahlen, modulo p, wobei p eine Primzahl ist. Es sieht aus wie eine Wolke von Punkten. Wir verwenden dieses Feld der positiven natürlichen Zahlen, um Approximationen zu vermeiden.
p ist eine Primzahl und es ist die Ordnung der verwendeten Kurve.
Schließlich lautet die Gleichung, die im Bitcoin-Protokoll verwendet wird: $$y^2 = (x^3 + 7) mod(p)$$
Die Gleichung der elliptischen Kurve in Bitcoin entspricht der letzten Gleichung im vorherigen Bild.

Im nächsten Abschnitt dieses Kurses werden wir Kurven verwenden, die sich einfach auf dem reellen Feld befinden, um das Verständnis zu erleichtern.

## Berechnung des öffentlichen Schlüssels aus dem privaten Schlüssel
<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>

Beginnen wir damit, in die Welt des Elliptic Curve Digital Signature Algorithm (ECDSA) einzutauchen. Bitcoin verwendet diesen digitalen Signaturalgorithmus, um private und öffentliche Schlüssel zu verknüpfen. In diesem System ist der private Schlüssel eine zufällige oder pseudozufällige 256-Bit-Zahl. Die Gesamtzahl der Möglichkeiten für einen privaten Schlüssel beträgt theoretisch 2^256, aber in der Realität ist sie etwas geringer. Genauer gesagt sind einige 256-Bit private Schlüssel für Bitcoin ungültig.

Um mit Bitcoin kompatibel zu sein, muss ein privater Schlüssel zwischen 1 und n-1 liegen, wobei n die Ordnung der elliptischen Kurve darstellt. Dies bedeutet, dass die Gesamtzahl der Möglichkeiten für einen Bitcoin-privaten Schlüssel fast gleich 1,158 x 10^77 ist. Um dies in Perspektive zu setzen, handelt es sich ungefähr um die gleiche Anzahl von Atomen im beobachtbaren Universum.

![image](assets/image/section2/3.webp)

Der eindeutige private Schlüssel, bezeichnet als k, wird dann verwendet, um einen öffentlichen Schlüssel zu bestimmen.

Der öffentliche Schlüssel, bezeichnet als K, ist ein Punkt auf der elliptischen Kurve, der aus dem privaten Schlüssel mithilfe irreversibler Algorithmen wie ECDSA abgeleitet wird. Wenn wir Kenntnis vom privaten Schlüssel haben, ist es sehr einfach, den öffentlichen Schlüssel abzurufen. Wenn wir jedoch nur den öffentlichen Schlüssel haben, ist es unmöglich, den privaten Schlüssel abzurufen. Diese Unumkehrbarkeit ist das Fundament der Sicherheit von Bitcoin-Wallets.

Der öffentliche Schlüssel ist 512 Bits lang, da er einem Punkt auf der Kurve mit einer x-Koordinate von 256 Bits und einer y-Koordinate von 256 Bits entspricht. Er kann jedoch zu einer 264-Bit-Zahl komprimiert werden.

![image](assets/image/section2/4.webp)

Der Generatorpunkt (G) ist der Punkt auf der Kurve, von dem aus alle öffentlichen Schlüssel im Bitcoin-Protokoll generiert werden. Er hat spezifische x- und y-Koordinaten, die normalerweise in hexadezimaler Form dargestellt werden. Für secp256k1 lauten die Koordinaten von G in hexadezimaler Form:

- `Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798`
- `Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8`
Dieser Punkt ist nützlich, um alle öffentlichen Schlüssel abzuleiten. Um den öffentlichen Schlüssel K zu berechnen, multiplizieren Sie einfach den Punkt G mit dem privaten Schlüssel k, so dass gilt: K = k.G

Wir werden nun untersuchen, wie Punkte auf elliptischen Kurven addiert und multipliziert werden.

#### Addition und Verdopplung von Punkten auf elliptischen Kurven

##### Hinzufügen von zwei Punkten M + L

Eine bemerkenswerte Eigenschaft von elliptischen Kurven ist, dass eine nicht-vertikale Linie, die die Kurve an zwei Punkten schneidet, sie auch an einem dritten Punkt schneiden wird, der in unserem Beispiel als Punkt O bezeichnet wird. Diese Eigenschaft wird verwendet, um den Punkt U zu bestimmen, der das Gegenteil von Punkt O ist.

M + L = U

![image](assets/image/section2/5.webp)

##### Hinzufügen eines Punktes zu sich selbst = Punktverdopplung

Das Hinzufügen eines Punktes G zu sich selbst erfolgt durch das Zeichnen einer Tangente an die Kurve an diesem Punkt. Diese Tangente schneidet die Kurve gemäß den Eigenschaften elliptischer Kurven an einem zweiten eindeutigen Punkt -J. Das Gegenteil dieses Punktes, J, ist das Ergebnis des Hinzufügens des Punktes G zu sich selbst.
G + G = J

Tatsächlich ist der Punkt G der Ausgangspunkt für die Berechnung aller öffentlichen Schlüssel der Benutzer des Bitcoin-Systems.

![image](assets/image/section2/6.webp)

#### Skalare Multiplikation auf elliptischen Kurven

Die skalare Multiplikation eines Punktes mit n entspricht dem Hinzufügen dieses Punktes zu sich selbst n-mal.

Ähnlich wie beim Punktverdopplung wird die skalare Multiplikation des Punktes G mit einem Punkt n durch das Zeichnen einer Tangente an die Kurve am Punkt G durchgeführt. Diese Tangente schneidet die Kurve gemäß den Eigenschaften elliptischer Kurven an einem zweiten eindeutigen Punkt -2G. Das Gegenteil dieses Punktes, 2G, ist das Ergebnis des Hinzufügens des Punktes G zu sich selbst.

Wenn n = 4 ist, wird die Operation wiederholt, bis 4G erreicht ist.

![image](assets/image/section2/7.webp)

Hier ist eine Beispielberechnung für 3G:

![image](assets/image/section2/8.webp)

Diese Operationen an Punkten einer elliptischen Kurve bilden die Grundlage für die Berechnung öffentlicher Schlüssel. Das Ableiten eines öffentlichen Schlüssels, wenn der private Schlüssel bekannt ist, ist sehr einfach.
Ein öffentlicher Schlüssel ist ein Punkt auf der elliptischen Kurve, er ist das Ergebnis unserer Addition und Verdopplung des Punktes G k-mal. Mit k = privater Schlüssel.

In diesem Beispiel:

- Der private Schlüssel k = 4
- Der öffentliche Schlüssel K = kG = 4G

![image](assets/image/section2/9.webp)

Wenn der private Schlüssel k bekannt ist, ist es einfach, den öffentlichen Schlüssel K zu berechnen. Es ist jedoch unmöglich, den privaten Schlüssel basierend auf dem öffentlichen Schlüssel abzurufen. Handelt es sich hierbei um das Ergebnis einer Addition oder einer Verdopplung von Punkten?

In unserer nächsten Lektion werden wir untersuchen, wie eine digitale Signatur mit dem ECDSA-Algorithmus und einem privaten Schlüssel zum Ausgeben von Bitcoins erstellt wird.

## Signieren mit dem privaten Schlüssel
<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

Der Prozess der digitalen Signatur ist eine wichtige Methode, um nachzuweisen, dass Sie der Inhaber eines privaten Schlüssels sind, ohne ihn preiszugeben. Dies wird mit Hilfe des ECDSA-Algorithmus erreicht, der das Bestimmen einer eindeutigen Nonce, das Berechnen einer spezifischen Zahl V und das Erstellen einer digitalen Signatur aus zwei Teilen, S1 und S2, umfasst.
Es ist entscheidend, immer eine eindeutige Nonce zu verwenden, um Sicherheitsangriffe zu vermeiden. Ein berüchtigtes Beispiel dafür, was passieren kann, wenn diese Regel nicht befolgt wird, ist das Hacken der PlayStation 3, die aufgrund der Wiederverwendung von Nonce kompromittiert wurde.

![](assets/image/section2/10.webp)

Schritte:

- Bestimmen Sie eine Nonce v, die eine eindeutige Zufallszahl ist.
  Nonce = Number Only Used Once (Zahl, die nur einmal verwendet wird).
  Sie wird von der Person bestimmt, die die Signatur durchführt.
- Berechnen Sie durch Addition und Verdopplung von Punkten auf einer elliptischen Kurve vom Punkt G, der Position von V auf der elliptischen Kurve.
  So dass V = v.G
  x und y sind die Koordinaten von V auf der Ebene.
- Berechnen Sie S1.
  S1 = x mod n mit n = die Ordnung der Kurve und x eine Koordinate von V auf der Ebene.
  Hinweis: Die Anzahl der möglichen öffentlichen Schlüssel ist größer als die Anzahl der Punkte auf der elliptischen Kurve im endlichen Feld der positiven ganzen Zahlen, das in Bitcoin verwendet wird.
  Die Ordnung der Kurve entspricht nur den Möglichkeiten, die der öffentliche Schlüssel auf der Kurve annehmen kann.
- Berechnen Sie S2.
  H(Tx) = Hash der Transaktion
k = der private Schlüssel- Berechnen Sie die Signatur: die Verkettung von S1 + S2.
- Berechnen Sie P, die Signaturverifikationsberechnung.
  K = der öffentliche Schlüssel

Um beispielsweise den öffentlichen Schlüssel 3G zu erhalten, ziehen Sie eine Tangente zum Punkt G, berechnen Sie das Gegenteil von -G, um 2G zu erhalten, und fügen Sie dann G und 2G hinzu. Um eine Transaktion durchzuführen, müssen Sie nachweisen, dass Sie die Zahl 3 kennen, indem Sie die mit dem öffentlichen Schlüssel 3G verbundenen Bitcoins entsperren.

Um eine digitale Signatur zu erstellen und nachzuweisen, dass Sie den privaten Schlüssel kennen, der mit dem öffentlichen Schlüssel 3G verbunden ist, berechnen Sie zunächst eine Zufallszahl (Nonce) und dann den Punkt V, der mit diesem Nonce verbunden ist (im gegebenen Beispiel ist es 4G). Anschließend berechnen Sie den Punkt T, indem Sie den öffentlichen Schlüssel 3G und den Punkt V addieren, was 7G ergibt.

![image](assets/image/section2/11.webp)

Lassen Sie uns den Prozess der digitalen Signatur vereinfachen.
In dem vorherigen Bild ist der private Schlüssel k = 3.
Wir können den öffentlichen Schlüssel K, der mit diesem privaten Schlüssel verbunden ist, leicht berechnen: K = 3G.
Dann generieren wir eine Zufallszahl (Nonce): v = 4.
Aus diesem Nonce ist es möglich, V zu berechnen, sodass: V = v.G = 4G.

Von diesem Punkt V aus berechnen wir den Punkt T, sodass:
T = t.G = 7G (mit t = 7).

Jetzt ist es an der Zeit, mit der Überprüfung der digitalen Signatur fortzufahren.

Die Überprüfung einer digitalen Signatur ist ein entscheidender Schritt bei der Verwendung des ECDSA-Algorithmus, der die Authentizität einer signierten Nachricht bestätigt, ohne den privaten Schlüssel des Absenders zu benötigen. So funktioniert es im Detail:

In unserem Beispiel haben wir zwei wichtige Werte: t und V.
t ist ein numerischer Wert (in diesem Beispiel 7) und V ist ein Punkt auf der elliptischen Kurve (hier durch 4G dargestellt). Diese Werte werden während der Erstellung der digitalen Signatur generiert und dann zusammen mit der Nachricht gesendet, um die Überprüfung zu ermöglichen.

Wenn der Überprüfer die Nachricht erhält, erhält er auch diese beiden Werte, t und V.

Hier sind die Schritte, die der Überprüfer befolgt, um die Signatur zu validieren:

1. Zuerst berechnet er den Hash der Nachricht, den wir H nennen.
2. Dann berechnet er u1 und u2. Dazu verwendet er die folgenden Formeln:
   - u1 = H /\* (S2)^-1 mod n
   - u2 = T /\* (S2)^-1 mod n
     Wobei S2 der zweite Teil der digitalen Signatur ist, n die Ordnung der elliptischen Kurve ist und (S2)^-1 das Inverse von S2 mod n ist.
3. Der Überprüfer berechnet dann einen Punkt P' auf der elliptischen Kurve mit der Formel: P' = u1 _ G + u2 _ K
   - G ist der Generatorpunkt der Kurve
   - K ist der öffentliche Schlüssel des Absenders
4. Der Überprüfer berechnet dann I', was einfach die x-Koordinate des Punktes P' modulo n ist.
5. Schließlich bestätigt der Überprüfer, dass I' gleich t ist. Wenn dies der Fall ist, wird die Signatur als gültig betrachtet. Andernfalls ist die Signatur ungültig.
Dieses Verfahren stellt sicher, dass nur der Absender, der den entsprechenden privaten Schlüssel besitzt, eine Signatur erstellen konnte, die diesen Überprüfungsprozess besteht.

![image](assets/image/section2/12.webp)

In einfacheren Worten:
Die Person, die die Signatur erstellt, gibt die Zahl t (in unserem Beispiel t = 7) und den Punkt V an die Person weiter, die sie überprüft.
Es ist unmöglich, den öffentlichen Schlüssel oder den privaten Schlüssel aus der Zahl 7 und der Zahl V zu bestimmen.

Die Schritte zur Überprüfung der digitalen Signatur sind wie folgt:

- Auf der Kurve addiert der Verifizierer den Punkt des öffentlichen Schlüssels zum Punkt V, um den Punkt T' zu erhalten.
- Der Verifizierer berechnet die Zahl t.G.
- Der Verifizierer überprüft, ob das Ergebnis von t.G tatsächlich der Zahl T' entspricht.

Zusammenfassend ist die Überprüfung einer digitalen Signatur ein wesentlicher Vorgang bei Bitcoin-Transaktionen. Sie stellt sicher, dass die signierte Nachricht während der Übertragung nicht verändert wurde und dass der Absender tatsächlich der Inhaber des privaten Schlüssels ist. Diese digitale Authentifizierungstechnik basiert auf komplexen mathematischen Prinzipien, einschließlich elliptischer Kurvenarithmetik, und gewährleistet gleichzeitig die Vertraulichkeit des privaten Schlüssels. Sie bietet eine solide Sicherheitsgrundlage für kryptografische Transaktionen.

Das Management dieser Schlüssel sowie deren Erstellung sind jedoch weitere wichtige Fragen bei Bitcoin. Wie generiert man ein neues Schlüsselpaar? Wie organisiert man eine Vielzahl von Schlüsseln sicher und effizient? Wie stellt man sie bei Bedarf wieder her?

Um diese Fragen zu beantworten und Ihr Verständnis für die Sicherheit von Kryptografie zu vertiefen, wird sich unser nächster Kurs auf das Konzept der Hierarchisch Deterministischen Wallets (HD Wallets) und die Verwendung von mnemonischen Phrasen konzentrieren. Diese Mechanismen bieten elegante Möglichkeiten, Ihre Kryptowährungsschlüssel effektiv zu verwalten und die Sicherheit zu erhöhen.

# Die mnemonische Phrase
<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## Entwicklung von Bitcoin-Wallets
<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

Die Hierarchisch Deterministische Wallet, allgemein bekannt als HD Wallet, spielt eine herausragende Rolle im Kryptowährungsökosystem. Der Begriff "Wallet" mag für Neulinge auf diesem Gebiet irreführend sein, da er nicht das Halten von Geld oder Währungen umfasst. Stattdessen bezieht er sich auf eine Sammlung kryptografischer privater Schlüssel.

Die frühen Wallets waren Software, die privat bestimmte Schlüssel pseudozufällig gruppierten, aber keine Verbindung zwischen ihnen hatten. Diese Wallets werden "Just a Bunch Of Keys" (JBOK) genannt.

Da die Schlüssel keine Verbindung zueinander haben, muss der Benutzer für jedes neu generierte Schlüsselpaar eine neue Sicherungskopie erstellen. Entweder verwendet der Benutzer immer dasselbe Schlüsselpaar und gefährdet die Vertraulichkeit oder er generiert zufällig ein neues Schlüsselpaar und muss daher eine neue Sicherungskopie dieser Schlüssel erstellen.

Die Komplexität der Verwaltung dieser Schlüssel wird jedoch durch eine Reihe von Protokollen namens Bitcoin Improvement Proposals (BIPs) ausgeglichen. Diese Upgrade-Vorschläge sind der Kern der Funktionalität und Sicherheit von HD Wallets. Zum Beispiel hat [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), das 2012 eingeführt wurde, die Art und Weise, wie diese Schlüssel generiert und gespeichert werden, revolutioniert, indem das Konzept der deterministisch und hierarchisch abgeleiteten Schlüssel eingeführt wurde. Die Idee besteht darin, alle Schlüssel deterministisch und hierarchisch aus einer eindeutigen Information abzuleiten: dem Seed. Dadurch wird der Prozess der Sicherung dieser Schlüssel erheblich vereinfacht, während ihr Sicherheitsniveau erhalten bleibt.

Anschließend führte [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) eine bedeutende Innovation ein: die 24-Wort-Mnemonic-Phrase. Dieses System verwandelte eine komplexe und schwer zu merkende Zahlenfolge in eine Reihe gewöhnlicher Wörter, was das Merken und Speichern erheblich erleichterte. Zusätzlich schlug [BIP38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki) vor, eine zusätzliche Passphrase hinzuzufügen, um die Sicherheit einzelner Schlüssel zu erhöhen. Diese aufeinanderfolgenden Verbesserungen führten zu den Standards BIP43 und BIP44, die die Struktur und Hierarchisierung von HD-Wallets standardisierten und sie für die breite Öffentlichkeit zugänglicher und benutzerfreundlicher machten.

In den folgenden Abschnitten werden wir tiefer in die Funktionsweise von HD-Wallets eintauchen. Wir werden die Prinzipien der Schlüsselableitung erläutern und die grundlegenden Konzepte von Entropie und Zufallszahlenerzeugung untersuchen, die für die Sicherheit Ihres HD-Wallets unerlässlich sind.

Zusammenfassend ist es wichtig, die zentrale Rolle von BIP32 und BIP39 bei der Gestaltung und Sicherheit von HD-Wallets hervorzuheben. Diese Protokolle ermöglichen die Generierung mehrerer Schlüssel aus einem einzigen Seed, der eine zufällige oder pseudo-zufällige Zahl sein soll. Heutzutage werden diese Standards von der Mehrheit der Kryptowährungs-Wallets übernommen, unabhängig davon, ob sie einer einzelnen Kryptowährung gewidmet sind oder mehrere Arten von Währungen unterstützen.

## Entropie und Zufallszahl
<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>

Die Bedeutung der Sicherheit des privaten Schlüssels im Bitcoin-Ökosystem ist unbestreitbar. Sie sind tatsächlich der Grundpfeiler, der die Sicherheit von Bitcoin-Transaktionen gewährleistet. Um jegliche Schwachstellen in Bezug auf Vorhersagbarkeit zu vermeiden, müssen diese Schlüssel auf wirklich zufällige Weise generiert werden, was schnell zu einer mühsamen Aufgabe werden kann. Das Problem ist, dass es in der Informatik unmöglich ist, eine wirklich zufällige Zahl zu generieren, da sie zwangsläufig aus einem deterministischen Prozess, einem Code, abgeleitet wird. Aus diesem Grund ist es wichtig, sich mit den verschiedenen Arten von Zufallszahlengeneratoren (RNG) vertraut zu machen. Die Arten von RNG variieren von Pseudo-Zufallszahlengeneratoren (PRNG) bis hin zu echten Zufallszahlengeneratoren (TRNG) sowie PRNGs, die eine Quelle für Entropie einbeziehen.

Entropie bezieht sich auf den "Unordnungszustand" eines Systems. Aus einer externen Entropie, das heißt, einer externen Informationsquelle, ist es möglich, mithilfe eines Zufallszahlengenerators eine Zufallszahl zu erhalten.

![Bild](assets/image/section3/2.webp)

Schauen wir uns an, wie ein Pseudo-Zufallszahlengenerator (PRNG) funktioniert.

Er nimmt einen Seed als Eingabe, der dem internen Zustand 0 entspricht.
Auf diesem internen Zustand wird eine Transformationsfunktion angewendet, und das Ergebnis, das eine Pseudo-Zufallszahl ist, entspricht dem internen Zustand 1.
Auf diesem internen Zustand 1 wird erneut eine Transformationsfunktion angewendet, was zu einer neuen Zufallszahl = internem Zustand 2 führt.
Und so weiter.

Der Hauptnachteil besteht darin, dass jeder identische Seed immer die gleiche Ausgabe erzeugt. Außerdem können wir, wenn wir das Ergebnis der anfänglichen Transformationsfunktionen kennen, die Zufallszahl am Ausgang des Prozesses abrufen.

Ein Beispiel für eine Transformationsfunktion ist die PBKDF2-Funktion.

**Zusammenfassend muss ein kryptographisch sicherer PRNG:**

- statistisch zufällig sein
- unvorhersagbar sein
- widerstandsfähig sein, selbst wenn die Ergebnisse offengelegt werden
- eine ausreichend lange Periode haben

![Bild](assets/image/section3/3.webp)

Im Falle von Bitcoin werden private Schlüssel aus einer einzigen Information am Anfang der Brieftasche generiert. Diese Information ermöglicht die deterministische und hierarchische Ableitung von Kinderschlüsselpaaren. Entropie ist die Grundlage jeder HD-Brieftasche, obwohl es keinen Standard für die Generierung dieser Zufallszahl gibt. Daher ist die Generierung von Zufallszahlen eine große Herausforderung bei der Sicherung von Bitcoin-Transaktionen.

## Die mnemonische Phrase
<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>

Die Sicherheit einer Bitcoin-Brieftasche ist ein Hauptanliegen für alle Benutzer. Eine wesentliche Möglichkeit, die Sicherung der Brieftasche zu gewährleisten, besteht darin, eine mnemonische Phrase auf der Grundlage von Entropie und Prüfsumme zu generieren.

![Bild](assets/image/section3/5.webp)

Um Entropie in eine mnemonische Phrase umzuwandeln, berechnen Sie einfach die Prüfsumme der Entropie und verknüpfen Sie die Entropie und die Prüfsumme.

Sobald die Entropie generiert ist, wird die SHA256-Funktion auf die Entropie angewendet, um einen Hash zu erstellen.
Die ersten 8 Bits des Hashes werden abgerufen, was die Prüfsumme ist.
Die mnemonische Phrase ist das Ergebnis der Entropie, die zur Prüfsumme hinzugefügt wird.

Die Prüfsumme gewährleistet die Überprüfung der Genauigkeit der Wiederherstellungsphrase. Ohne diese Prüfsumme könnte ein Fehler in der Phrase zur Erstellung einer anderen Brieftasche und somit zum Verlust von Geldern führen. Die Prüfsumme wird erhalten, indem die Entropie durch die SHA256-Funktion geleitet und die ersten 8 Bits des Hashes abgerufen werden.

![Bild](assets/image/section3/6.webp)

Je nach Größe der Entropie gibt es verschiedene Standards für die mnemonische Phrase. Der am häufigsten verwendete Standard für eine 24-Wort-Wiederherstellungsphrase ist eine Entropie von 256 Bits. Die Größe der Prüfsumme wird durch die Division der Größe der Entropie durch 32 bestimmt.

Beispielsweise erzeugt eine Entropie von 256 Bits eine 8-Bit-Prüfsumme. Die Verknüpfung von Entropie und Prüfsumme führt dann zu entsprechenden Größen von 128 Bits, 160 Bits usw. Abhängig von der Größe der Entropie besteht die Wiederherstellungsphrase aus 12 Wörtern für 128 Bits, 15 Wörtern für 160 Bits und 24 Wörtern für 256 Bits.

**Codierung der mnemonischen Phrase:**

![Bild](assets/image/section3/7.webp)

Die letzten 8 Bits entsprechen der Prüfsumme.
Jedes 11-Bit-Segment wird in Dezimalzahlen umgewandelt.
Jede Dezimalzahl entspricht einem Wort aus einer Liste von 2048 Wörtern auf BIP39. Es ist wichtig zu beachten, dass kein Wort die gleiche Reihenfolge der ersten vier Buchstaben hat.

Es ist unerlässlich, die 24-Wort-Wiederherstellungsphrase zur Erhaltung der Integrität der Bitcoin-Brieftasche zu sichern. Die beiden am häufigsten verwendeten Standards basieren auf einer Entropie von 128 oder 256 Bits und einer Verknüpfung von 12 oder 24 Wörtern. Das Hinzufügen einer Passphrase ist eine zusätzliche Option, um die Sicherheit der Brieftasche zu erhöhen.

Zusammenfassend ist die Generierung einer mnemonischen Phrase zur Sicherung einer Bitcoin-Brieftasche ein entscheidender Prozess. Es ist wichtig, sich an die Standards der mnemonischen Phrase basierend auf der Größe der Entropie zu halten. Die Sicherung der 24-Wort-Wiederherstellungsphrase ist unerlässlich, um einen Verlust von Geldern zu verhindern.

## Die Passphrase
<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>

Die Passphrase ist ein zusätzliches Kennwort, das in eine Bitcoin-Brieftasche integriert werden kann, um ihre Sicherheit zu erhöhen. Die Verwendung ist optional und liegt im Ermessen des Benutzers. Durch Hinzufügen beliebiger Informationen, die zusammen mit der mnemonischen Phrase die Berechnung des Seeds der Brieftasche ermöglichen, erhöht die Passphrase ihre Sicherheit.

![Bild](assets/image/section3/8.webp)

Die Passphrase ist ein optionaler kryptografischer Salt, dessen Größe vom Benutzer festgelegt wird. Sie verbessert die Sicherheit einer HD-Wallet, indem sie beliebige Informationen hinzufügt, die in Kombination mit der mnemonischen Phrase die Berechnung des Seeds ermöglichen.

Nachdem sie bei der Erstellung einer Wallet festgelegt wurde, ist sie für die Ableitung aller Schlüssel der Wallet erforderlich. Die Funktion pbkdf2 wird verwendet, um den Seed aus der Passphrase zu generieren. Dieser Seed ermöglicht die Ableitung aller Kinderschlüsselpaare der Wallet. Wenn die Passphrase geändert wird, wird die Bitcoin-Wallet vollständig verändert.

Die Passphrase ist ein wichtiges Instrument zur Verbesserung der Sicherheit von Bitcoin-Wallets. Sie ermöglicht die Umsetzung verschiedener Sicherheitsstrategien. Zum Beispiel kann sie verwendet werden, um Duplikate zu erstellen und das Backup der mnemonischen Phrase zu erleichtern. Sie kann auch die Sicherheit der Wallet verbessern, indem sie die Risiken im Zusammenhang mit der zufälligen Generierung der mnemonischen Phrase verringert.

Eine effektive Passphrase sollte lang (20 bis 40 Zeichen) und vielfältig sein (Groß- und Kleinbuchstaben, Zahlen und Symbole verwenden). Sie sollte nicht direkt mit dem Benutzer oder seiner Umgebung in Verbindung stehen. Es ist sicherer, eine zufällige Zeichenfolge anstelle eines einfachen Wortes als Passphrase zu verwenden.

![image](assets/image/section3/9.webp)

Eine Passphrase ist sicherer als ein einfaches Passwort. Die ideale Passphrase ist lang, vielfältig und zufällig. Sie kann die Sicherheit einer Wallet oder einer Hot-Software verbessern. Sie kann auch verwendet werden, um redundante und sichere Backups zu erstellen.

Es ist wichtig, sich um Passphrase-Backups zu kümmern, um den Zugriff auf die Wallet nicht zu verlieren. Eine Passphrase ist eine Option für eine HD-Wallet. Sie kann zufällig mit Würfeln oder einem anderen Pseudozufallszahlengenerator generiert werden. Es wird nicht empfohlen, sich eine Passphrase oder mnemonische Phrase zu merken.

In unserer nächsten Lektion werden wir detailliert auf die Funktionsweise des Seeds und des ersten daraus generierten Schlüsselpaars eingehen. Fühlen Sie sich frei, diesem Kurs zu folgen, um Ihr Lernen fortzusetzen. Wir freuen uns darauf, Sie bald wiederzusehen.

# Erstellung von Bitcoin-Wallets
<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## Erstellung des Seeds und des Master Keys
<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

In diesem Teil des Kurses werden wir die Schritte zur Ableitung einer Hierarchisch Deterministischen Wallet (HD-Wallet) untersuchen, die die hierarchische und deterministische Erstellung und Verwaltung von privaten und öffentlichen Schlüsseln ermöglicht.

![image](assets/image/section4/0.webp)

Die Grundlage der HD-Wallet beruht auf zwei wesentlichen Elementen: der mnemonischen Phrase und der Passphrase (optional zusätzliches Passwort). Zusammen bilden sie den Seed, eine alphanumerische Sequenz von 512 Bits, die als Grundlage für die Ableitung der Schlüssel der Wallet dient. Aus diesem Seed ist es möglich, alle Kinderschlüsselpaare der Bitcoin-Wallet abzuleiten. Der Seed ist der Schlüssel, der Zugriff auf alle mit der Wallet verbundenen Bitcoins gewährt, unabhängig davon, ob eine Passphrase verwendet wird oder nicht.

![image](assets/image/section4/1.webp)

Um den Seed zu erhalten, wird die Funktion pbkdf2 (Password-Based Key Derivation Function 2) mit der mnemonischen Phrase und der Passphrase verwendet. Die Ausgabe von pbkdf2 ist ein 512-Bit Seed.

Aus dem Seed ist es möglich, den Master-Privatschlüssel und den Chain Code mithilfe des HMAC SHA-512 (Hash-based Message Authentication Code Secure Hash Algorithm 512) Algorithmus zu bestimmen. Dieser Algorithmus erfordert eine Nachricht und einen Schlüssel als Eingabe, um ein Ergebnis zu generieren. Der Master-Privatschlüssel wird aus dem Seed und der Phrase "Bitcoin SEED" berechnet. Diese Phrase ist für alle Ableitungen aller HD-Wallets identisch und gewährleistet Konsistenz zwischen den Wallets.
Ursprünglich wurde die SHA-512-Funktion nicht im Bitcoin-Protokoll implementiert, weshalb HMAC SHA-512 verwendet wird. Die Verwendung von HMAC SHA-512 mit dem Ausdruck "Bitcoin SEED" schränkt den Benutzer ein, eine Brieftasche spezifisch für Bitcoin zu generieren. Das Ergebnis von HMAC SHA-512 ist eine 512-Bit-Zahl, die in zwei Teile aufgeteilt ist: die linken 256 Bits repräsentieren den Master-Privatschlüssel, während die rechten 256 Bits den Master-Chain-Code repräsentieren.

![image](assets/image/section4/2.webp)

Der Master-Privatschlüssel ist der übergeordnete Schlüssel aller zukünftigen Schlüssel in der Brieftasche, während der Master-Chain-Code an der Ableitung von Kinderschlüsseln beteiligt ist. Es ist wichtig zu beachten, dass es unmöglich ist, ein Kinderschlüsselpaar abzuleiten, ohne den entsprechenden Chain-Code des übergeordneten Paares zu kennen.

Ein Schlüsselpaar in der Brieftasche besteht aus einem privaten Schlüssel, einem öffentlichen Schlüssel und einem Chain-Code. Der Chain-Code führt eine Quelle der Zufälligkeit in der Ableitung von Kinderschlüsseln ein und isoliert jedes Schlüsselpaar, um ein mögliches Informationsleck zu verhindern.
Es ist wichtig zu beachten, dass der Master-Privatschlüssel der erste aus dem Seed abgeleitete private Schlüssel ist und keine Verbindung zu den erweiterten Schlüsseln der Brieftasche hat.

In der nächsten Lektion werden wir erweiterte Schlüssel im Detail untersuchen, wie z. B. xPub, xPRV, zPub, und verstehen, warum sie verwendet werden und wie sie konstruiert werden.

## Erweiterte Schlüssel
<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

In diesem Teil der Lektion werden wir erweiterte Schlüssel (xPub, zPub, yPub) und ihre Präfixe untersuchen, die eine wichtige Rolle bei der Ableitung von Kinderschlüsseln in einer hierarchisch deterministischen Brieftasche (HD-Wallet) spielen.

![image](assets/image/section4/3.webp)

Erweiterte Schlüssel unterscheiden sich von Master-Schlüsseln. Eine HD-Brieftasche generiert eine mnemonische Phrase und einen Seed, um den Master-Schlüssel und den Master-Chain-Code zu erhalten. Erweiterte Schlüssel werden verwendet, um Kinderschlüssel abzuleiten und erfordern sowohl den übergeordneten Schlüssel als auch den entsprechenden Chain-Code. Ein erweiterter Schlüssel kombiniert diese beiden Informationen, um den Ableitungsprozess zu vereinfachen.

![image](assets/image/section4/4.webp)

Erweiterte öffentliche Schlüssel können nur normale öffentliche Kinderschlüssel ableiten, während erweiterte private Schlüssel sowohl normale öffentliche als auch private Kinderschlüssel ableiten können, sei es durch normale oder gehärtete Ableitung. Gehärtete Ableitung erfolgt vom übergeordneten privaten Schlüssel, während normale Ableitung der Ableitung vom übergeordneten öffentlichen Schlüssel entspricht.

Die Verwendung von erweiterten Schlüsseln mit dem Präfix XPUB ermöglicht die Ableitung neuer Adressen, ohne zu den entsprechenden privaten Schlüsseln zurückkehren zu müssen, was eine bessere Sicherheit bietet. Die mit erweiterten Schlüsseln verbundenen Metadaten liefern wichtige Informationen über ihre Rolle und Position in der Schlüsselhierarchie.

Erweiterte Schlüssel werden durch spezifische Präfixe (XPRV, XPUB, YPUB, ZPUB) identifiziert, die anzeigen, ob es sich um einen erweiterten privaten oder öffentlichen Schlüssel handelt, sowie um seinen spezifischen Zweck. Die mit einem erweiterten Schlüssel verbundenen Metadaten umfassen die Version (Präfix), Tiefe, Fingerabdruck des übergeordneten Schlüssels, Index und Payload (Chain-Code und übergeordneter Schlüssel).

![image](assets/image/section4/5.webp)

Die Version entspricht dem Typ des Schlüssels: xpub, xprv, ...

Die Tiefe entspricht der Anzahl der Ableitungen zwischen übergeordneten und Kinderschlüsseln seit dem Master-Schlüssel.

Der Fingerabdruck des übergeordneten Schlüssels sind die ersten 4 Bytes des Hash 160 des übergeordneten Schlüssels.
Der Index ist die Nummer des Paares, das zur Generierung des erweiterten Schlüssels unter seinen Geschwistern verwendet wird. (Geschwister = Schlüssel mit gleicher Tiefe) Wenn wir beispielsweise das xpub unseres 3. Kontos ableiten möchten, lautet der Index 2 (weil der Index bei 0 beginnt).
Die Nutzlast besteht aus dem Chain-Code (32 Bytes) und dem Elternschlüssel (33 Bytes).
Komprimierte öffentliche Schlüssel haben eine Größe von 33 Bytes, während rohe öffentliche Schlüssel 512 Bits haben. Komprimierte öffentliche Schlüssel behalten die gleichen Informationen wie rohe Schlüssel, sind jedoch kleiner. Erweiterte Schlüssel haben eine Größe von 82 Bytes und ihr Präfix wird in Base 58 durch eine Konvertierung in Hexadezimal dargestellt. Die Prüfsumme wird mit der HASH256-Hashfunktion berechnet.

![Bild](assets/image/section4/6.webp)

Verbesserte Ableitungen beginnen bei Indizes, die Potenzen von 2 (2^31) sind. Es ist interessant zu beachten, dass die am häufigsten verwendeten Präfixe xpub und zpub sind, die jeweils den Legacy-Standards und SegWit v1 und SegWit v0 entsprechen.

In unserer nächsten Lektion werden wir uns auf die Ableitung von Kinderschlüsselpaaren konzentrieren, indem wir das Wissen über erweiterte Schlüssel und den Master-Schlüssel der Brieftasche nutzen.

## Ableitung von Kinderschlüsselpaaren
<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

Wie bereits erwähnt, haben wir die Berechnung des Seeds und des Master-Schlüssels besprochen, die die ersten wesentlichen Elemente für die hierarchische Organisation und Ableitung der HD (Hierarchical Deterministic) Brieftasche sind. Der Seed, mit einer Länge von 128 bis 256 Bits, wird zufällig oder aus einer geheimen Phrase generiert. Er spielt eine deterministische Rolle bei der Ableitung aller anderen Schlüssel. Der Master-Schlüssel ist der erste Schlüssel, der aus dem Seed abgeleitet wird, und er ermöglicht die Ableitung aller anderen Kinderschlüsselpaare.

Der Master-Chain-Code spielt eine wichtige Rolle bei der Wiederherstellung der Brieftasche aus dem Seed. Es sollte beachtet werden, dass alle aus demselben Seed abgeleiteten Schlüssel denselben Master-Chain-Code haben werden.

![Bild](assets/image/section4/7.webp)

Die hierarchische Organisation und Ableitung der HD-Brieftasche bieten eine effizientere Verwaltung von Schlüsseln und Brieftaschenstrukturen. Erweiterte Schlüssel ermöglichen die Ableitung eines Kinderschlüsselpaars aus einem Elternschlüsselpaar mithilfe mathematischer Berechnungen und spezifischer Algorithmen.
Es gibt verschiedene Arten von Kinderschlüsselpaaren, einschließlich verstärkter Schlüssel und normaler Schlüssel. Der erweiterte öffentliche Schlüssel ermöglicht nur die Ableitung normaler Kinderschlüssel, während der erweiterte private Schlüssel die Ableitung aller Kinderschlüssel ermöglicht, sowohl öffentlicher als auch privater, unabhängig davon, ob sie im normalen oder verstärkten Modus sind. Jedes Schlüsselpaar hat einen Index, der sie voneinander unterscheidet.

![Bild](assets/image/section4/8.webp)

Die Ableitung von Kinderschlüsseln verwendet die HMAC-SHA512-Funktion, wobei der Elternschlüssel mit dem Index und dem mit dem Schlüsselpaar verbundenen Chain-Code konkateniert wird. Normale Kinderschlüssel haben einen Index von 0 bis 2 hoch 31 minus 1, während verstärkte Kinderschlüssel einen Index von 2 hoch 31 bis 2 hoch 32 minus 1 haben.

![Bild](assets/image/section4/9.webp)

![Bild](assets/image/section4/10.webp)

Es gibt zwei Arten von Kinderschlüsselpaaren: verstärkte Paare und normale Paare. Der Prozess der Ableitung von Kinderschlüsseln verwendet öffentliche Schlüssel, um Ausgabenbedingungen zu generieren, während private Schlüssel zum Signieren verwendet werden. Der erweiterte öffentliche Schlüssel ermöglicht nur die Ableitung normaler öffentlicher Kinderschlüssel, während der erweiterte private Schlüssel die Ableitung aller Kinderschlüssel ermöglicht, sowohl öffentlicher als auch privater, im normalen oder verstärkten Modus.

![Bild](assets/image/section4/11.webp)
![Bild](assets/image/section4/12.webp)

Verstärkte Ableitung verwendet den übergeordneten privaten Schlüssel, während normale Ableitung den übergeordneten öffentlichen Schlüssel verwendet. Die HMAC-SHA512-Funktion wird für die verstärkte Ableitung verwendet, während die normale Ableitung eine 512-Bit-Prüfsumme verwendet. Der öffentliche Schlüssel des Kindes wird erhalten, indem der private Schlüssel des Kindes mit dem Generator der elliptischen Kurve multipliziert wird.

![image](assets/image/section4/13.webp)
![image](assets/image/section4/14.webp)

Durch die hierarchische Ableitung und die deterministische Ableitung vieler Schlüsselpaare kann eine Baumstruktur für die hierarchische Ableitung erstellt werden. In der nächsten Lektion dieses Trainings werden wir uns die Struktur des HD-Wallets sowie die Ableitungspfade genauer ansehen, wobei der Schwerpunkt auf der Notation der Ableitungspfade liegt.

## Wallet-Struktur und Ableitungspfade
<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

In diesem Kapitel werden wir uns die Struktur des Ableitungsbaums in einem Hierarchisch Deterministischen Wallet (HD-Wallet) genauer ansehen. Wir haben bereits die Berechnung des Seeds, den Master-Schlüssel und die Ableitung von Kinderschlüsselpaaren untersucht. Jetzt werden wir uns auf die Organisation von Schlüsseln innerhalb des Wallets konzentrieren.

Das HD-Wallet verwendet Tiefenschichten, um Schlüssel zu organisieren. Jede Ableitung von einem Elternpaar zu einem Kindpaar entspricht einer Tiefenschicht.

![image](assets/image/section4/15.webp)

- Tiefenschicht 0 entspricht dem Master-Schlüssel und dem Master-Chain-Code.

- Tiefenschicht 1 wird verwendet, um Kinderschlüssel für einen bestimmten Zweck abzuleiten, der durch den Index bestimmt wird. Die Zwecke entsprechen den BIP 84- und Segwit v0/v1-Standards.

- Tiefenschicht 2 ermöglicht die Unterscheidung von Konten für verschiedene Kryptowährungen oder Netzwerke. Dadurch kann das Wallet basierend auf verschiedenen Geldquellen organisiert werden. Für Bitcoin wird der Index 0 sein.

- Tiefenschicht 3 wird verwendet, um das Wallet in verschiedene Konten zu organisieren und eine klarere und strukturiertere Struktur bereitzustellen.

- Tiefenschicht 4 entspricht den externen und internen Ketten, die für Adressen verwendet werden, die öffentlich kommuniziert werden sollen. Index 0 ist mit der externen Kette verbunden, während Index 1 mit der internen Kette verbunden ist. Jedes Konto hat zwei Ketten: die externe Kette (0) und die interne Kette (1). Tiefenschicht 4 wird auch verwendet, um Skripttypen im Fall von Multi-Signatur-Wallets zu verwalten.

- Tiefenschicht 5 wird für Empfangsadressen in einem Standard-Wallet verwendet. Im nächsten Abschnitt werden wir die Ableitung von Kinderschlüsselpaaren genauer untersuchen.

![image](assets/image/section4/16.webp)

Für jede Tiefenschicht verwenden wir Indizes, um Kinderschlüsselpaare zu unterscheiden.

Der Index ohne Apostroph entspricht dem tatsächlich verwendeten Index, während der Index mit Apostroph dem tatsächlichen Index + 2^31 entspricht. Verstärkte Ableitungen verwenden Indizes von 2^31 bis 2^32-1. Zum Beispiel entspricht der Index 44' dem tatsächlichen Index 2^31 + 44.

Um eine bestimmte Empfangsadresse zu generieren, leiten wir ein Kinderschlüsselpaar aus dem Master-Schlüssel und dem Master-Chain-Code ab. Dann verwenden wir den Index, um zwischen verschiedenen Kinderschlüsselpaaren derselben Tiefe zu unterscheiden.
Erweiterte Schlüssel wie XPUB ermöglichen es Ihnen, Ihr Wallet mit mehreren Personen zu teilen. Der Ableitungspfad wird verwendet, um zwischen der externen Kette (Adressen, die geteilt werden sollen) und der internen Kette (Wechseladressen) zu unterscheiden.

Im nächsten Kapitel werden wir uns mit Empfangsadressen, ihren Vorteilen und den Schritten, die zu ihrer Erstellung erforderlich sind, genauer befassen.

# Was ist eine Bitcoin-Adresse?
<partId>81ec8d17-f8ee-5aeb-8035-d370866f4281</partId>

## Bitcoin-Adressen
<chapterId>0a887ed8-3424-5a52-98e1-e4b406150475</chapterId>

In diesem Kapitel werden wir uns mit Empfangsadressen befassen, die eine entscheidende Rolle im Bitcoin-System spielen. Sie ermöglichen es, Gelder in einer Transaktion zu empfangen und werden aus Paaren von privaten und öffentlichen Schlüsseln generiert. Obwohl es einen Skripttyp namens Pay2PublicKey gibt, der Bitcoins an einen öffentlichen Schlüssel bindet, ziehen es Benutzer im Allgemeinen vor, anstelle dieses Skripts Empfangsadressen zu verwenden.

Wenn ein Empfänger Bitcoins empfangen möchte, gibt er dem Sender anstelle seines öffentlichen Schlüssels eine Empfangsadresse an. Eine Adresse ist tatsächlich ein Hash eines öffentlichen Schlüssels mit einem bestimmten Format. Der öffentliche Schlüssel wird aus dem Kind-Privatschlüssel mithilfe mathematischer Operationen wie Punktaddition und Verdopplung auf elliptischen Kurven abgeleitet.

Es ist wichtig zu beachten, dass es nicht möglich ist, von einer Adresse auf den öffentlichen Schlüssel oder von einem öffentlichen Schlüssel auf den privaten Schlüssel zurückzuschließen. Die Verwendung einer Adresse reduziert die Größe der Informationen des öffentlichen Schlüssels, die anfangs 512 Bits beträgt.

Bitcoin-Adressen wurden verkleinert, um ihre Verwendung zu erleichtern. Sie haben eine Prüfsumme, die Tippfehler erkennt und das Risiko des Verlusts von Bitcoins verringert. Öffentliche Schlüssel haben jedoch keine Prüfsumme, was bedeutet, dass Tippfehler zum Verlust der entsprechenden Gelder führen können.

Adressen bieten auch eine zweite Sicherheitsebene zwischen öffentlichen und privaten Informationen, was es schwieriger macht, die Kontrolle über den privaten Schlüssel zu erlangen.

Es ist unerlässlich, darauf hinzuweisen, dass jede Adresse nur einmal verwendet werden sollte. Die Wiederverwendung derselben Adresse birgt Datenschutzprobleme und sollte vermieden werden.

Für Bitcoin-Adressen werden verschiedene Präfixe verwendet. Zum Beispiel entspricht BC1Q einer Segwit V0-Adresse, BC1P einer Taproot/Segwit V1-Adresse und Präfixe 1 und 3 sind mit Pay2PublicKeyH/Pay2ScriptH (Legacy)-Adressen verbunden. In der nächsten Lektion werden wir Schritt für Schritt erklären, wie man eine Adresse aus einem öffentlichen Schlüssel ableitet.

## Wie erstellt man eine Bitcoin-Adresse?
<chapterId>6dee7bf3-7767-5f8d-a01b-659b95cfe0a5</chapterId>

In diesem Kapitel werden wir die Konstruktion einer Empfangsadresse für Bitcoin-Transaktionen diskutieren. Eine Empfangsadresse ist eine alphanumerische Darstellung eines komprimierten öffentlichen Schlüssels. Die Umwandlung eines öffentlichen Schlüssels in eine Empfangsadresse umfasst mehrere Schritte.

### Schritt 1: Komprimierung des öffentlichen Schlüssels

Ein öffentlicher Schlüssel wird aus einem Kind-öffentlichen Schlüssel abgeleitet.

Ein öffentlicher Schlüssel ist ein Punkt auf der elliptischen Kurve. Dank der Symmetrie der elliptischen Kurve wird ein Punkt auf der elliptischen Kurve mit nur zwei möglichen Werten für y assoziiert: positiv oder negativ. 
Im Bitcoin-Protokoll arbeiten wir jedoch mit einer endlichen Menge von positiven Ganzzahlen anstelle der Menge der reellen Zahlen. Um zwischen den beiden möglichen Werten von y zu unterscheiden, genügt es anzugeben, ob y gerade oder ungerade ist.

Die Komprimierung eines öffentlichen Schlüssels reduziert seine Größe von 520 Bits auf 264 Bits.

Wir verwenden das Präfix 0x02 für ein gerades y und 0x03 für ein ungerades y. Dies ist die komprimierte Form des öffentlichen Schlüssels.

### Schritt 2: Hashing des komprimierten öffentlichen Schlüssels

Der Hash des komprimierten öffentlichen Schlüssels wird mit der SHA256-Funktion berechnet. Anschließend wird die RIPEMD160-Funktion auf den Digest angewendet.

### Schritt 3: Die Nutzlast = Adressnutzlast

Der binäre Digest von RIPEMD160(SHA256(K)) wird verwendet, um Gruppen von 5 Bits zu bilden. Jede Gruppe wird in Basis16 (Hexadezimal) und/oder Basis 10 umgewandelt.

### Schritt 4: Hinzufügen von Metadaten für die Prüfsummenberechnung mit dem BCH-Programm

![Bild](assets/image/section5/5.webp)

Im Fall von Legacy-Adressen verwenden wir die doppelte SHA256-Hashfunktion, um die Adressprüfsumme zu generieren. Für Segwit V0- und V1-Adressen verlassen wir uns jedoch auf die BCH-Prüfsummentechnologie, um Fehlererkennung zu gewährleisten. Das BCH-Programm ist in der Lage, Fehler vorzuschlagen und zu korrigieren, wobei die Wahrscheinlichkeit eines Fehlers äußerst gering ist. Derzeit wird das BCH-Programm verwendet, um Fehler zu erkennen und Änderungen vorzuschlagen, führt diese jedoch nicht automatisch im Namen des Benutzers aus.

Das BCH-Programm erfordert verschiedene Eingabeinformationen, einschließlich des HRP (Human Readable Part), das erweitert werden muss. Die Erweiterung des HRP beinhaltet die Codierung jedes Buchstabens in Basis 2 gemäß ihrem ASCII-Code. Dann werden die ersten 3 Bits des Ergebnisses für jeden Buchstaben genommen und in Basis 10 umgewandelt (in Blau in der Abbildung). Fügen Sie einen Trenner 0 ein. Dann werden die folgenden 5 Bits jedes zuvor in Basis 10 umgewandelten Buchstabens aneinandergehängt (in Gelb in der Abbildung).

Die Erweiterung des HRP in Basis 10 ermöglicht es, die letzten fünf Bits jedes Zeichens zu isolieren und somit die Prüfsumme zu verstärken.

Die Segwit V0-Version wird durch den Code 00 repräsentiert und die "Payload" ist in Schwarz, in Basis 10. Dies wird von sechs reservierten Zeichen für die Prüfsumme gefolgt.

### Schritt 5: Berechnung der Prüfsumme mit dem BCH-Programm

![Bild](assets/image/section5/6.webp)

Die Eingabe mit den Metadaten wird dann dem BCH-Programm übergeben, um die Prüfsumme in Basis 10 zu erhalten.

Hier haben wir die Prüfsumme.

### Schritt 6: Adresskonstruktion und Umwandlung in Bech32

![Bild](assets/image/section5/7.webp)

Die Verkettung von Version, Payload und Prüfsumme ermöglicht den Aufbau der Adresse. Die Zeichen in Basis 10 werden dann mithilfe einer Korrespondenztabelle in Bech32-Zeichen umgewandelt. Das Bech32-Alphabet umfasst alle alphanumerischen Zeichen, außer 1, b, i und o, um Verwechslungen zu vermeiden.

### Schritt 7: Hinzufügen des HRP und des Trennzeichens

![Bild](assets/image/section5/8.webp)

In Pink die Prüfsumme.
In Schwarz die Payload = der Hash des öffentlichen Schlüssels.
In Blau die Version.

Alles wird in Bech32 umgewandelt, dann wird 'bc' für Bitcoin hinzugefügt und '1' als Trennzeichen, und hier ist die Adresse.

# Gehe weiter
<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## Erstellen eines Seeds aus 128 Würfelwürfen!
<chapterId>0f4d40a7-cf0e-5faf-bc4d-691486771ac1</chapterId>

Das Erstellen einer mnemonischen Phrase ist ein entscheidender Schritt zur Sicherung Ihrer Kryptowährungs-Wallet. Es gibt verschiedene Methoden zur Generierung einer mnemonischen Phrase, jedoch konzentrieren wir uns auf die manuelle Generierungsmethode mit Würfeln. Es ist wichtig zu beachten, dass diese Methode nicht für eine Wallet mit hohem Wert geeignet ist. Es wird empfohlen, Open-Source-Software oder eine Hardware-Wallet zu verwenden, um die mnemonische Phrase zu generieren. Um eine mnemonische Phrase zu erstellen, verwenden wir Würfel, um binäre Informationen zu generieren. Das Ziel ist es, den Prozess des Erstellens der mnemonischen Phrase zu verstehen.

**Schritt 1 - Vorbereitung:**
Stellen Sie sicher, dass Sie eine amnestische Linux-Distribution, wie z.B. Tails OS, auf einem USB-Stick installiert haben, um die Sicherheit zu erhöhen. Beachten Sie, dass dieses Tutorial nicht zur Erstellung einer Haupt-Wallet verwendet werden sollte.
**Schritt 2 - Generieren einer zufälligen binären Zahl:**
Wir werden Würfel verwenden, um binäre Informationen zu generieren. Werfen Sie einen Würfel 128 Mal und notieren Sie jedes Ergebnis (1 für ungerade, 0 für gerade).

**Schritt 3 - Organisieren der binären Zahlen:**
Ordnen Sie die erhaltenen binären Zahlen in Reihen mit 11 Ziffern, um weitere Berechnungen zu erleichtern. Die zwölfte Reihe sollte nur 7 Ziffern haben.

**Schritt 4 - Berechnung der Prüfsumme:**
Die letzten 4 Ziffern der zwölften Reihe entsprechen der Prüfsumme. Um diese Prüfsumme zu berechnen, benötigen wir ein Terminal aus einer Linux-Distribution. Es wird empfohlen, [TailOs](https://tails.boum.org/index.fr.html) zu verwenden, das eine bootfähige speicherlose Distribution von einem USB-Stick ist. Geben Sie auf Ihrem Terminal den Befehl `echo <binäre Zahl> | shasum -a 254 -0` ein. Ersetzen Sie `<binäre Zahl>` durch Ihre Liste von 128 Nullen und Einsen. Die Ausgabe ist ein hexadezimaler Hash. Notieren Sie sich das erste Zeichen dieses Hashs und konvertieren Sie es in binär. Sie können diese [Tabelle](https://www.educative.io/answers/decimal-binary-and-hex-conversion-table) zur Hilfe verwenden. Fügen Sie die binäre Prüfsumme (4 Ziffern) zur zwölften Reihe Ihres Blattes hinzu.

**Schritt 5 - Umwandlung in Dezimalzahlen:**
Um die Wörter, die mit jeder Ihrer Reihen verbunden sind, zu finden, müssen Sie zuerst jede Serie von 11 Bits in Dezimalzahlen umwandeln. Hier können Sie keinen Online-Konverter verwenden, da diese Bits Ihre mnemonische Phrase darstellen. Daher müssen Sie mit einem Taschenrechner und einem Trick wie folgt umrechnen: Jedes Bit ist mit einer Potenz von 2 verbunden, sodass wir von links nach rechts 11 Ränge haben, die 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1 entsprechen. Um Ihre Serie von 11 Bits in Dezimalzahlen umzuwandeln, addieren Sie nur die Ränge, die eine 1 enthalten. Zum Beispiel für die Serie 00110111011 entspricht dies der folgenden Addition: 256 + 128 + 32 + 16 + 8 + 2 + 1 = 443. Sie können nun jede Reihe in Dezimalzahlen umwandeln. Und bevor Sie zur Codierung in Wörter übergehen, fügen Sie allen Reihen +1 hinzu, da der Index der BIP39-Wortliste bei 1 und nicht bei 0 beginnt.

**Schritt 8 - Generieren der mnemonischen Phrase:**
Beginnen Sie damit, die [Liste der 2048 Wörter](https://seedxor.com/files/wordlist.pdf) auszudrucken, um zwischen Ihren Dezimalzahlen und den BIP39-Wörtern zu konvertieren. Das Besondere an dieser Liste ist, dass kein Wort die ersten 4 Buchstaben mit einem anderen Wort in diesem Wörterbuch teilt. Suchen Sie dann nach dem Wort, das mit jeder Ihrer Zeilen und der dazugehörigen Dezimalzahl verbunden ist.

**Schritt 9 - Test der mnemonischen Phrase:**
Testen Sie Ihre mnemonische Phrase sofort auf der Sparrow Wallet, indem Sie eine Brieftasche daraus erstellen. Wenn Sie einen Fehler bei der Prüfsumme erhalten, haben Sie wahrscheinlich einen Berechnungsfehler gemacht. Korrigieren Sie diesen Fehler, indem Sie zu Schritt 4 zurückkehren und erneut auf der Sparrow Wallet testen. Voilà! Sie haben gerade eine neue Bitcoin-Brieftasche aus 128 Würfelwürfen erstellt.

Das Generieren einer mnemonischen Phrase ist ein wichtiger Prozess, um Ihre Kryptowährungsbrieftasche zu sichern. Es wird empfohlen, sicherere Methoden wie die Verwendung von Open-Source-Software oder einer Hardware-Brieftasche zu verwenden, um die mnemonische Phrase zu generieren. Das Abschließen dieses Workshops hilft jedoch dabei, besser zu verstehen, wie wir eine Bitcoin-Brieftasche aus einer Zufallszahl erstellen können.

## BONUS: Interview mit Théo Pantamis
<chapterId>39f0ec5a-e258-55cb-9789-bc46d314d816</chapterId>

Eine weitere weit verbreitete kryptografische Methode im Bitcoin-Protokoll ist die Methode der digitalen Signaturen.

![video](https://youtu.be/c9MvtGJsEvY?si=bQ1N5NCd6op0G6nW)



## Geben Sie uns Ihr Feedback zu diesem Kurs
<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>
<isCourseReview>true</isCourseReview>
## Fazit und Abschluss
<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

### Vielen Dank und weiterhin viel Erfolg

Wir möchten uns herzlich bei Ihnen bedanken, dass Sie den Kurs Crypto 301 abgeschlossen haben. Wir hoffen, dass diese Erfahrung für Sie bereichernd und lehrreich war. Wir haben viele spannende Themen behandelt, von Mathematik über Kryptographie bis hin zur Funktionsweise des Bitcoin-Protokolls.

Wenn Sie sich weiter mit dem Thema beschäftigen möchten, haben wir eine zusätzliche Ressource für Sie. Wir haben ein exklusives Interview mit Théo Pantamis und Loïc Morel geführt, zwei renommierten Experten auf dem Gebiet der Kryptographie. In diesem Interview werden verschiedene Aspekte des Themas ausführlich behandelt und interessante Perspektiven geboten.

Schauen Sie sich gerne dieses Interview an, um das faszinierende Feld der Kryptographie weiter zu erkunden. Wir hoffen, dass es Ihnen nützlich und inspirierend auf Ihrer Reise sein wird. Nochmals vielen Dank für Ihre Teilnahme und Ihr Engagement während dieses Kurses.

### Unterstützen Sie uns

Dieser Kurs sowie alle Inhalte dieser Universität wurden Ihnen kostenlos von unserer Community zur Verfügung gestellt. Um uns zu unterstützen, können Sie ihn mit anderen teilen, Mitglied der Universität werden und sogar über GitHub zu seiner Entwicklung beitragen. Im Namen des gesamten Teams bedanken wir uns bei Ihnen!

### Bewerten Sie den Kurs
Ein Bewertungssystem für das Training wird in Kürze in diese neue E-Learning-Plattform integriert! In der Zwischenzeit vielen Dank, dass Sie den Kurs absolviert haben, und wenn er Ihnen gefallen hat, überlegen Sie bitte, ihn mit anderen zu teilen.
