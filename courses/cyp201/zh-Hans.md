---
name: 比特币密码学算法介绍
goal: 从密码学角度理解比特币钱包的创建过程
objectives:
  - 理解与比特币相关的密码学术语。
  - 掌握创建比特币钱包的过程。
  - 理解比特币钱包的结构。
  - 理解地址和推导路径。
---

# 密码学之旅

您对比特币感到好奇吗？想要了解比特币钱包是如何运作的吗？那您准备好踏上一段引人入胜的密码学之旅吧！Loïc，我们的专家，将引导您穿越创建比特币钱包的复杂过程，揭开哈希（hashing）、密钥推导（key derivation）和椭圆曲线（elliptic curves）等令人生畏的技术术语背后的秘密。

这次培训不仅会让您掌握理解比特币钱包结构的知识，还会让您准备深入探索密码学的激动人心的世界。那么，您准备好踏上这段旅程了吗？加入我们的世界，将您的好奇心转化为专业知识吧！

+++

# 引言
<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## 密码学简介
<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

### 这个培训适合您吗？一定适合您！

我们很高兴欢迎您参加由其领域专家Loïc Morel主导的新培训课程“Crypto 301：密码学和分层确定性钱包钱包（HD钱包）简介”。这个课程将带您深入密码学这一奇妙的世界，密码学是确保您的数据加密和安全的数学基础学科。

在我们的日常生活中，特别是在比特币领域，密码学扮演着至关重要的作用。与密码学相关的概念，如私钥、公钥、地址、推导路径、种子和熵，是使用和创建比特币钱包的核心。在整个课程中，Loïc将详细解释私钥是如何生成的，以及它们是如何与地址关联的。Loïc还将花一个小时来解释椭圆曲线的数学细节。此外，您将了解为何使用HMAC SHA512对保护您的钱包很重要，以及了解种子和助记词短语之间的区别。
这次培训的最终目标是使您能够理解创建HD钱包和使用的密码学方法所涉及的技术过程。多年来，比特币钱包已经变得更易于使用、更安全，并且得益于特定的比特币改进建议（Bitcoin Improvement Proposal，BIP）而标准化。Loïc将帮助您理解这些BIP，以把握比特币开发者和密码学家所做出的选择。像我们大学提供的所有培训一样，这个课程的内容是完全免费和开源的。这意味着您可以随意参加并使用它。我们期待在这个激动人心的课程结束时收到您的反馈。

### 讲台交给您了，教授！

大家好，我叫Loïc Morel，将是您们通过比特币钱包使用的密码学技术探索的向导。

我们的旅程从深入了解密码学哈希函数开始。我们将一起解剖SHA256的内部工作原理，并探索用于推导的各种算法。

我们将继续我们的冒险，解密数字签名的神秘世界。您将发现椭圆曲线的魔法如何应用于这些签名，并且我们将阐明如何从私钥计算公钥。当然，我们还将深入数字签名的过程。
接下来，我们将回到过去时代，了解比特币钱包的演变，并将深入探讨熵和随机数的概念。我们将回顾著名的助记词，同时也会触及到密码短语。您甚至将有机会通过从128次骰子投掷中创建种子，体验一些独特的事情！
有了这些坚实的基础，我们将为关键部分做好准备：创建一个比特币钱包。从种子和主密钥的诞生，到扩展密钥的研究，再到子密钥对的推导，我们将详细解析每一步骤。我们还将讨论钱包的结构和推导路径。

最后，我们将通过检查比特币地址来结束我们的旅程。我们将解释它们是如何创建的，以及它们在比特币钱包功能中扮演的重要角色。

和我一起同行，开始这一迷人的旅程，准备以前所未有的方式探索密码学的世界。把您的先入为主放在一边，敞开心扉，以一种新的方式理解比特币及其基本结构。

# 哈希函数
<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## 介绍与比特币相关的密码学哈希函数
<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

欢迎来到今天的课程，专门深入探讨密码学世界中的哈希函数，这是比特币协议安全的关键基石。您可以将哈希函数视为一个超高效的密码学解密机器人，它能将任何大小的信息转换成一个独特的、固定大小的数字指纹，其被称为“哈希（Hash）”、“摘要（Digest）”或“校验和（Checksum)”。
总的来说，哈希函数会接收任意大小的输入消息，并将其转换成固定大小的输出指纹。

为了阐述密码学哈希函数的特性，我们需要理解两个基本特点：它们的不可逆性和抗伪造性。

不可逆性，或抗原像攻击性，意味着可以轻松地根据输入计算出输出，但无法按照输出计算输入。
它是一个单向函数。

![image](assets/image/section1/0.webp)

抗伪造性来自于这样一个事实：最轻微的输入修改一定会导致截然不同的输出。
这些函数允许验证下载软件的真实性。

![image](assets/image/section1/1.webp)

它们拥有的另一个关键特性是抗碰撞和抗二次原像。当两个不同的输入产生相同的输出时，就发生了碰撞。
当然，在哈希世界中，碰撞是不可避免的，但优秀的密码学哈希函数会显著地最小化碰撞的发生。风险必须如此之低，以至于可被视为微不足道。就像每个哈希都是一个庞大城市中的一所房子；尽管房子数量庞大，一个好的哈希函数确保每所房子都有一个独一无二的地址。

抗二次原像依赖于抗碰撞；如果存在抗碰撞性，那么就存在抗二次原像性。
给定一个强加于我们的输入信息，我们必须找出第二个与第一个不同的输入，它在函数的输出哈希中产生碰撞。抗二次原像类似于抗碰撞，但在这种情况下，输入是强加的。
现在，我们将一起航行在过时哈希函数的波涛汹涌之中。SHA0、SHA1和MD5现在被认为加密哈希海洋中的“生锈壳体”。它们通常不被推荐使用，因为它们已经失去了对碰撞的抵抗力。根据鸽巢原理，尽管我们尽了最大努力，由于输出大小的限制，我们无法避免碰撞的发生。被视为安全的哈希函数必须抵抗碰撞、第二原像和原像。

在比特币协议中，SHA-256哈希函数是这艘船的船长。其他函数，如SHA-512，用于与HMAC和PBKDF的推导。此外，RIPMD160用于将指纹大小减少到160位。当我们提到HASH256和HASH160时，我们指的是使用SHA-256和RIPMD进行双重哈希。

对于HASH256函数，它是使用SHA256函数对消息进行的双重哈希。
$$
SHA256(SHA256(message))
$$
首先，HASH160函数使用SHA256，然后使用RIPMD160对消息进行的双重哈希。
$$
RIPMD160(SHA256(message))
$$
使用HASH160特别有利，因为它减小指纹的大小，同时保证SHA-256的安全性。

总之，加密哈希函数的终极目标是将任意大小的信息转换为固定大小的指纹。被认为安全的加密哈希函数必须具有几个优点：不可逆性、抗篡改性、抗碰撞性和抗第二原像性。

![image](assets/image/section1/2.webp)

在这次探索的终点，我们揭开了加密哈希函数的神秘面纱，强调了它们在比特币协议中的用途，并解析了它们的具体目标。我们已了解到，被认为安全的哈希函数必须抵抗原像、第二原像、碰撞和篡改。我们还覆盖了比特币协议中使用的不同哈希函数的范围。在下一节中，我们将深入SHA256哈希函数的核心，探索赋予其独特特性的奇妙数学原理。

## SHA256的内部工作原理
<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>

欢迎来到加密哈希函数迷宫探索旅程的下一章节。今天，我们将揭开SHA256的神秘面纱，这是一个我们之前已经介绍的复杂但巧妙过程。
作为一名熟练的专业翻译人员，我的主要任务是准确地将技术内容从英语翻译成简体中文，同时遵循所提供的指南。这是文本的翻译：

作为提醒，SHA256哈希函数的目的是接受任意大小的输入消息并生成一个256位的哈希作为输出。

### 预处理

让我们在SHA256的迷宫中继续前进，从预处理开始。

#### 填充位（Padding Bits）

这个第一步的目标是使消息等于512位的倍数。为了实现这一点，我们将向消息添加填充位。

设M为初始消息大小。
设1为分隔符保留的一位。
设P为用于填充的位数，64为第二阶段预处理保留的位数。
总数应为512位的倍数，其由n表示。

![image](assets/image/section1/3.webp)

以一个950位的输入消息为例：

```
第一步：确定大小；其最终所需的位数。
第一个大于（M + 64 + 1）（其中M = 950）的512的倍数为1024。1024 = 2 * 512
因此， n = 2。

第二步：确定P，即达到最终所需位数需要添加的填充位数。
-> M + 1 + P + 64 = n * 512
-> M + 1 + P + 64 = 2 * 512
-> 950 + 1 + P + 64 = 1024
-> P = 1024 - 1 - 64 - 950
-> P = 9

因此，需要添加9个填充位以使消息等于512的倍数。

接下来怎么做？
在初始消息之后，需要添加分隔符位1，然后是P位的填充值，在这个例子中，P为九个0位。

```
消息 + 1 000 000 000
```

#### 大小填充 （Size Padding）

我们现在进入预处理的第二阶段，这涉及到添加初始消息大小的二进制表示形式的位数。

让我们使用一个输入为950位的示例：

```
数字950的二进制表示为：11 1011 0110

我们使用前一步骤保留的64位。我们添加零以将我们的64位四舍五入到我们的等量输入。然后，我们合并初始消息、填充位和大小填充以获取我们的等量输入。
```

这个过程的结果如下：

![image](assets/image/section1/4.webp)

### 处理

#### 理解前提条件

##### 常数和初始化向量

现在，我们正在准备处理SHA-256函数的初始步骤。就像任何好的食谱一样，我们需要一些基本材料，我们将其称为常数和初始化向量。

初始化向量，从A到H，是前8个质数的平方根的小数部分的前32位。它们将在初始处理步骤中作为基本值服务。它们的值以十六进制格式表示。

常数K，从0到63，代表前64个质数的立方根的小数部分的前32位。它们用于压缩函数的每一迭代。它们的值也以十六进制格式表示。

![image](assets/image/section1/5.webp)

##### 使用的运算

在压缩函数中，我们使用特定的算子，如XOR、AND和NOT。我们根据它们的位置逐位处理位，使用XOR算子和真值表。AND算子只有在两个运算数等于1才会返回输出值1，NOT算子用于返回运算数的相反值。我们还使用SHR算子将位向右移动选定的数字。

真值表如下：

![image](assets/image/section1/6.webp)

位移运算如下：

![image](assets/image/section1/7.webp)

#### 压缩函数

在应用压缩函数之前，我们将输入分成512位的块。每个块将独立于其他块进行处理。

然后，每个512位块将进一步被分成32位的块，其被称为W。这样，W(0)代表512位块的前32位。W(1)代表接下来的32位，依此类推，直到我们达到块的512位。
一旦所有常数K和数据块W已被定义，我们就可以对每个数据块W在每一轮中执行以下计算。
我们在压缩函数中执行64轮计算。在最后一轮，即“函数的输出”阶段，我们将得到一个中间状态，该状态将被添加到压缩函数的初始状态中。

然后，我们重复这些压缩函数的步骤，处理下一个512位块，直到最后一个块。

压缩函数中的所有加法都是模2^32加法，以始终保持32位的总和。

![image](assets/image/section1/9.webp)

![image](assets/image/section1/8.webp)

##### 压缩函数的一轮

![image](assets/image/section1/11.webp)

![image](assets/image/section1/10.webp)

压缩函数将执行64次。我们有我们的数据块W和我们之前定义的常数K作为输入。
红色方块/叉号对应于模2^32位加法。

输入A、B、C、D、E、F、G、H将与一个32位值关联，总共32 * 8 = 256位。
我们还有一个新的序列A、B、C、D、E、F、G、H作为输出。这个输出将随后用作下一轮的输入，如此循环，直到第64轮结束。

压缩函数第一轮的输入序列的值对应于之前提到的预定义初始化向量。
作为提醒，初始化向量代表前8个质数的平方根的十进制部分的前32位。

这是一轮的示例：

![image](assets/image/section1/12.1.webp)

##### 中间状态

作为提醒，消息被分成512位的块，然后被分成32位的片段。对于每个512位块，我们应用64轮压缩函数。
中间状态对应于一个块的64轮结束时。这第64轮的输出序列的值用作下一个块的第一轮的输入序列的初始值。

![image](assets/image/section1/12.2.webp)

#### 哈希函数的概述

![image](assets/image/section1/13.webp)

由图可见，第一个512位消息片段的输出对应于我们的初始化向量作为第二个512位消息片段的输入，依此类推。

最后一轮的输出，即最后一片的输出，对应于SHA256函数的最终结果。

总之，我们想强调在CH、MAJ、σ0和σ1盒中执行的计算的关键作用。这些操作，以及其他操作，是确保SHA256哈希函数抵御攻击的守护者，使其成为保护许多数字系统的首选，特别是在比特币协议中。当然，尽管复杂，SHA256的美在于其能够从哈希中找到输入，而对给定输入验证哈希则是一项机械简单的操作。

## 用来推导的算法
<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>
HMAC 和 PBKDF2 推导算法是比特币协议安全机制中的关键组成部分。它们防止了多种潜在攻击，并确保了比特币钱包的真实性。HMAC 和 PBKDF2 是用于比特币中各种任务的加密工具。HMAC 主要用于在推导分层确定性（HD）钱包时抵御长度扩展攻击，而 PBKDF2 用于将助记词短语转换为种子。

#### HMAC-SHA512

HMAC-SHA512 对有两个输入：消息 m（输入 1）和用户任意选择的密钥 K（输入 2）。它还有一个固定大小的输出：512 位。

我们将定义：
- m：用户选择的任意大小的消息（输入 1）
- K：用户选择的任意密钥（输入 2）
- K'：等化的密钥 K。它已根据哈希函数使用的块的大小 B 进行了调整。
- ||：连接运算符。
- opad：由字节 0x5c 重复 B 次定义的常数。
- ipad：由字节 0x36 重复 B 次定义的常数。
- B：所使用的哈希函数的块的大小。

![image](assets/image/section1/14.webp)

HMAC-SHA512，它以消息和密钥作为输入，生成固定大小的输出。为了确保其一致性，它将根据哈希函数中使用的块的大小调整密钥。对于HD钱包推导而言，使用 HMAC-SHA-512。它以 1024 位（128 字节）块模式操作，并相应地调整密钥。它使用 OPAD（0x5c）和 IPAD（0x36）常数，根据需要重复以增强安全性。

HMAC-SHA-512 过程涉及将对密钥 XOR OPAD 和密钥 XOR IPAD 与消息应用 SHA-512 的结果进行连接。如需当使用 1024 位（128 字节）块时，输入密钥将用零填充，然后与 IPAD 和 OPAD 进行异或。然后将修改后的密钥与消息连接。

![image](assets/image/section1/15.webp)

在字符串代码中包含盐增加了推导密钥的安全性。没有它，攻击者可能会危及整个钱包并窃取所有比特币。

PBKDF2 用于将助记词短语转换为种子。该算法使用 HMAC SHA512 执行 2048 轮。通过这些导出算法，不同的输入可以产生唯一且固定的输出，这缓解了 SHA-2 系列函数可能发生的长度扩展攻击问题。
长度扩展攻击者利用某些加密哈希函数的特定属性。在这种攻击中，已经拥有未知消息哈希的攻击者可使用它来计算更长消息的哈希，这是原始消息的扩展。这通常可以在未知原始消息内容的情况下完成，如果使用这种类型的哈希函数执行诸如真实性验证之类的任务，可能会导致重大的安全漏洞。

![image](assets/image/section1/16.webp)

总之，HMAC 和 PBKDF2 算法在比特币协议的 HD 钱包推导的安全中发挥着至关重要的作用。HMAC-SHA-512 用于防御长度扩展攻击，而 PBKDF2 允许将助记词短语转换为种子。字符串代码在密钥推导中增加了一个额外的熵源，确保了系统的健壮性。

# 数字签名
## 数字签名与椭圆曲线
<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

这些赫赫有名的比特币到底被存放在哪里？不是您想象的比特币钱包里。实际上，比特币钱包存储的是证明比特币所有权所必需的私钥。比特币本身却被记录在区块链上，这是一个分散的数据库，它存档了所有的交易。

在比特币系统中，账户单位是比特币（注意是小写的“b”）。它可以细分到八个小数位，最小单位是聪。UTXO，或者说“未花费的交易输出”，代表属于一个公钥的未花费交易输出，这个公钥通过数学方法与一个私钥相连。如果您想要花费这些比特币，您必须能够满足交易的花费条件。一个典型的花费条件涉及向网络的其他部分证明用户是与UTXO相关联的公钥的合法拥有者。为此，用户必须证明他们拥有与每个UTXO相关联的公钥对应的私钥，同时保持私钥的保密性。

这就是数字签名的用武之地。它作为数学证明，证明了某个特定公钥相关联的私钥的拥有权。这种数据保护技术主要基于一个名为椭圆曲线密码学（ECC）的奇妙密码学领域。

签名可以通过比特币网络中的其他参与者数学验证。

![image](assets/image/section2/0.webp)

为了确保交易的安全性，比特币依赖于两种数字签名协议：ECDSA（椭圆曲线数字签名算法）和Schnorr签名。ECDSA自2009年比特币推出以来仍然是集成到比特币中的签名协议，而Schnorr签名则在2021年11月较近期被添加。尽管两种协议都基于椭圆曲线密码学，并应用类似的数学机制，但它们主要在签名结构上有所不同。

在本课程中，我们将介绍ECDSA算法。

### 什么是椭圆曲线？

椭圆曲线密码学是一组算法，它们在密码学上下文中使用椭圆曲线及其各种几何和数学属性，其安全性基于计算离散对数的难度。

椭圆曲线在比特币协议的各种密码学应用中非常好用，其范围包括密钥交换到非对称加密和数字签名。

椭圆曲线有一些有趣的属性：

- 对称性：任何一条与椭圆曲线上的两个点相交的非垂直线，必定会在该曲线上的第三个点相交。
- 任何一条与椭圆曲线上的一个点相切的非垂直线，总会在一个特定的第二点与曲线相交。

比特币协议使用一个特定的椭圆曲线，被称为Secp256k1，进行其密码学操作。

在深入探讨这些签名机制之前，重要的是要了解椭圆曲线的概念。椭圆曲线由方程y² = x³ + ax + b定义。这个曲线上的每一点都有一种独特的对称性，这是其在密码学中有用的关键。

![image](assets/image/section2/1.webp)

最终，各种椭圆曲线被认为安全，用于密码学用途。最著名的可能是secp256r1曲线。然而，对于比特币，中本聪选择了一个不同的曲线：secp256k1。
这条曲线由参数 a=0 和 b=7 定义，其方程式为 y² = x³ + 7 模 n，其中 n 代表确定曲线阶的质数。
![image](assets/image/section2/2.webp)

第一张图片代表了在实数域上的 secp256k1 曲线及其方程式。
第二张图片是在 ZP 域（正自然数域）上的 secp256k1 曲线的表示，模 p，其中 p 是一个质数。它看起来像是一个点云。我们使用这个正自然数域是为了避免近似值。
p 是一个质数，它是所使用的曲线的阶。
最后，在比特币协议中使用的方程式是：$$
y^2 = (x^3 + 7) mod(p) $$
比特币中的椭圆曲线方程对应于前一张图片中的最后一个方程式。

在本课程的下一部分，我们将简单地使用实数域上的曲线，以便于理解。

## 从私钥计算公钥
<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>

首先，让我们深入了解椭圆曲线数字签名算法（ECDSA）。比特币利用这种数字签名算法将私钥和公钥连接起来。在这个系统中，私钥是一个随机或伪随机的256位数字。在理论上，私钥的总数为2^256，但实际上略少于此。确切地说，一些256位的私钥对于比特币来说是无效的。

为使私钥与比特币兼容，私钥必须在1和n-1之间，其中n代表椭圆曲线的阶。这意味着比特币私钥的总数几乎等于1.158 x 10^77。为了更好地了解，这大约是可观测宇宙中存在的原子数量。

![image](assets/image/section2/3.webp)

唯一的私钥，记为 k，将随后用来确定一个公钥。

公钥，记为 K，是椭圆曲线上的一个点，由私钥通过不可逆算法如ECDSA推导而来。当我们已知道私钥时，我们就很容易能够检索公钥，但当我们只有公钥时，就不可能检索私钥。这种不可逆性是比特币钱包安全的基石。

公钥长度为512位，因为它对应于曲线上的一个点：256位的x坐标和256位的y坐标。然而，它可以被压缩成一个264位的数字。

![image](assets/image/section2/4.webp)

生成点（Generator point，G）是比特币协议中所有公钥生成的曲线上的点。它有特定的x和y坐标，通常以十六进制表示。对于secp256k1，G的坐标，以十六进制表示为：

- `Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798`
- `Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8` 这个点对于推导所有公钥非常有用。为了计算公钥K，您只需将点G与私钥k相乘，即：K = k.G

我们现在将研究如何在椭圆曲线上加点和乘点。

#### 椭圆曲线上的点加和点倍

##### 加两个点 M + L

椭圆曲线的一个显著特性是，如果一条非垂直线与曲线上的两个点相交，它也将在该曲线上的第三点相交，我们例子中称之为点O。这个特性用于确定点U，它是点O的相反点。

M + L = U

![image](assets/image/section2/5.webp)

##### 点自加 = 点倍加（Point doubling）

将点G与自身相加的过程是通过在该点处画一条与曲线相切的切线来完成。根据椭圆曲线的性质，这条切线将在第二个特定的点-J与曲线相交。这个点的相反点，J，就是将点G加到自身的结果。
G + G = J

实际上，点G是计算比特币系统用户所有公钥的起点。

![image](assets/image/section2/6.webp)

#### 椭圆曲线上的标量乘法

对一个点进行标量乘法n相当于将该点与自身相加n次。

与点倍加相似，点G乘以点n的标量乘法是通过画一条在点G处相切的切线来完成的。根据椭圆曲线的性质，这条切线将在第二个独特的点-2G与曲线相交。这个点的相反点，2G，就是将点G加到自身的结果。

如果n = 4，那么操作重复直到达到4G。

![image](assets/image/section2/7.webp)

这里是一个3G的示例计算：

![image](assets/image/section2/8.webp)

这些在椭圆曲线上的点运算是计算公钥的基础。只要您知道私钥，您就很容易推导出公钥。
公钥是椭圆曲线上的一个点，它是我们将点G加倍和加点k次的结果。其中k = 私钥。

在这个例子中：

- 私钥 k = 4
- 公钥 K = kG = 4G

![image](assets/image/section2/9.webp)

知道私钥k，很容易计算出公钥K。然而，基于公钥无法检索私钥。这是点加还是点倍加的结果吗？

在我们的下一课中，我们将探讨如何使用私钥通过ECDSA算法创建数字签名来花费比特币。

## 使用私钥签名
<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

数字签名的过程是证明您是私钥持有者而不泄露它的关键方法。这是通过使用ECDSA算法实现的，该算法涉及确定一个唯一且一次性的随机数，计算一个特定的数字V，并创建由两部分S1和S2组成的数字签名。
使用唯一的一次性随机数（nonce）非常重要，以免安全攻击。一个因不遵循此规则而发生的臭名昭著的例子是PlayStation 3的黑客攻击，该事件的发生是由于nonce的重用。

![](assets/image/section2/10.webp)

该过程步骤如下：

- 确定一个随机数v，这是一个唯一的随机数。
  Nonce = Number Only Used Once（仅使用一次的数字）。
  它由签名者确定。
- 通过在椭圆曲线上加点和倍点从点G计算V在椭圆曲线上的位置。
  使得 V = v.G
  x和y为V在平面上的坐标。
- 计算S1。
  S1 = x mod n，其中n = 曲线的阶，x是V在平面上的一个坐标。
  注意：可能的公钥数量大于比特币中的有限整数域内椭圆曲线上的点数。
  曲线的阶仅对应于公钥在曲线上可以取的可能性。
- 计算S2。
  H(Tx) = 交易的哈希值
  k = 私钥
- 计算签名：S1 + S2的连接。
- 计算P，签名验证计算。
  K = 公钥

例如，为了得出公钥3G，您先需要画一条点G的切线，计算-G的相反数以获得2G，然后加上G和2G。如果您想要进行交易，您必须证明您知道数字3，通过解锁与公钥3G相关联的比特币。

为了创建数字签名并证明您知道与公钥3G关联的私钥，您首先需要计算一个随机数，然后计算与此随机数关联的点V（在给定的例子中，它是4G）。然后，您计算通过加上公钥3G和点V得到的点T，这给出了7G。

![image](assets/image/section2/11.webp)

让我们简化数字签名的过程。
在前面的图片中，私钥k = 3。
我们可以轻松计算与此私钥相关联的公钥K：K = 3G。
然后，我们伪随机生成一个随机数：v = 4。
从这个随机数，可以计算V使得：V = v.G = 4G。

从这个点V，我们计算点T使得：
T = t.G = 7G（其中t = 7）。

现在是进行数字签名验证的时候了。

验证数字签名是使用ECDSA算法的关键步骤，它允许在不需要发送者私钥的情况下确认签名消息的真实性。以下是详细操作方式：

在我们的例子中，我们有两个重要的值：t和V。
t是一个数值（在这个例子中为7），V是椭圆曲线上的一个点（这里表示为4G）。这些值在创建数字签名时生成，然后与消息一起发送以启用验证。

当验证者收到消息时，他们也会收到这两个值，t和V。

验证者将遵循以下步骤来验证签名：

1. 首先，他们将计算消息的哈希值，我们将其称为H。
2. 然后，他们将计算u1和u2。为此，他们将使用以下公式：
- u1 = H /\* (S2)^-1 mod n   - u2 = T /\* (S2)^-1 mod n
     其中S2是数字签名的第二部分，n是椭圆曲线的阶，(S2)^-1是S2模n的逆元。
3. 验证者将使用公式：P' = u1 _ G + u2 _ K 计算椭圆曲线上的一个点P'
   - G是曲线的生成点
   - K是发送者的公钥
4. 验证者接着计算I'，它是点P'的x坐标模n。
5. 最后，验证者将确认I'是否等于t。如果是这样，签名将被认为有效。如果不是，签名却被视为无效。
这个过程确保只有拥有相应私钥的发送者才能产生通过这一验证过程的签名。

![image](assets/image/section2/12.webp)

简单来说：
产生签名的人将提供数字t（在我们的例子中，t = 7）和点V给验证它的人。

从数字7和点V无法确定公钥或私钥。

验证数字签名的步骤如下：

- 在曲线上，验证者将公钥的点与点V相加以得出点T'。
- 验证者计算数字t.G。
- 验证者检查t.G的结果是否等于数字T'。

总之，验证数字签名是比特币交易中的一个重要程序。它确保了签名消息在传输过程中未被更改，并且发送者确实是私钥的持有者。这种数字认证技术基于复杂的数学原理，包括椭圆曲线算术，同时保持私钥的保密性。它为加密交易提供了坚实的安全基础。

尽管如此，这些密钥的管理以及它们的创建是比特币中的另一个重要问题。如何生成新的密钥对？如何安全高效地组织大量密钥？如何在必要时恢复它们？

为了回答这些问题并加深您对加密安全的理解，我们的下一课程将专注于分层确定性钱包（HD钱包）的概念和助记词的使用。这些机制提供了有效管理您的加密货币密钥的优雅方式，同时增强安全性。

# 助记词
<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## 比特币钱包的演变
<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

分层确定性钱包，更常被称为HD钱包，在加密货币生态系统中扮演着重要的角色。对于那些新入此领域的人来说，“钱包”这个词可能会让人误解，因为它并不涉及持有货币或货币。相反，它指的是一组加密私钥的集合。

早期的钱包是软件，以伪随机方式分组私有确定的密钥，但它们之间没有联系。这些钱包被称为“一堆密钥”（JBOK）。

由于密钥之间无关，用户需要为每生成一对新的密钥对做一个新的备份。
无论用户总是使用相同的密钥对并妥协保密性，还是随机生成一个新的密钥对，因此需要为这些密钥做一个新的备份。
然而，管理这些密钥的复杂性被一套称为比特币改进提案（BIPs）的协议所抵消。这些升级提案是HD钱包功能和安全性的核心。例如，[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)于2012年推出，通过引入确定性和分层推导密钥的概念，彻底改变了这些密钥的生成和存储方式。其思想是从一个独特的信息：种子，确定性和分层地推导所有密钥。这大大简化了备份这些密钥的过程，同时保持了它们的安全级别。
随后，[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)引入了一个重大创新：24个单词的助记词短语。这个系统将复杂且难以记忆的数字序列转变为一系列普通单词，使其更容易记忆和存储。此外，[BIP38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki)提出增加额外的密码短语以增强个别密钥的安全性。这些连续的改进导致了BIP43和BIP44标准的制定，这些标准规范了HD钱包的结构和分层，使它们对普通大众更加易用和友好。

在接下来的部分中，我们将更深入地探讨HD钱包的工作原理。我们将讨论密钥推导原则，并检查熵和随机数生成的基本概念，这些对于确保您的HD钱包的安全至关重要。

总之，强调BIP32和BIP39在HD钱包的设计和安全性中的中心作用是至关重要的。这些协议允许从单一种子生成多个密钥，这个种子应该是一个随机或伪随机数。如今，这些标准被大多数加密货币钱包采用，无论它们是专用于单一加密货币还是支持多种类型的货币。

## 熵和随机数
<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>

在比特币生态系统中，私钥安全的重要性不言而喻。它们确实是确保比特币交易安全的基石。为了避免与可预测性相关的任何漏洞，这些密钥必须以真正随机的方式生成，这很快就成为一项艰巨的任务。问题在于，在计算机科学中，生成一个真正随机的数是不可能的，因为它必然是从一个确定性过程中推导的；一个代码。这就是为什么了解不同的随机数生成器（RNG）至关重要。RNG的类型多种多样，从伪随机数生成器（PRNG）到真随机数生成器（TRNG），以及结合了熵源的PRNG。

熵指的是系统的“无序”状态。从外部熵，即外部信息源，可以使用随机数生成器获得一个随机数。

![image](assets/image/section3/2.webp)

让我们看看伪随机数生成器（PRNG）是如何运作的。

它以一个种子作为输入，该种子对应于内部状态0。
在这个内部状态上，应用一个转换函数，结果是一个伪随机数，对应于内部状态1。
在这个内部状态1上，再次应用一个转换函数，结果是一个新的随机数=内部状态2。
依此类推。
主要缺点是任何相同的种子总会产生相同的输出。此外，如果我们知道初始转换函数的结果，我们将能够检索出过程输出的随机数。
转换函数的一个例子是PBKDF2函数。

**总之，一个密码学安全的伪随机数生成器（PRNG）必须：**

- 统计上是随机的
- 不可预测的
- 即使结果被泄露也能保持其抵抗力
- 有足够长的周期

![image](assets/image/section3/3.webp)

对于比特币的情况，私钥是从钱包基础上的单一信息生成的。这些信息允许确定性和层次性地推导子密钥对。熵是每个HD钱包的基础，尽管没有生成这个随机数的标准。因此，随机数生成是确保比特币交易安全的一个主要挑战。

## 助记词
<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>

比特币钱包的安全是所有用户的主要关注点。确保钱包备份的一个基本方法是基于熵和校验和生成助记词。

![image](assets/image/section3/5.webp)

为了将熵转换为助记词，只需计算熵的校验和并将熵和校验和连接起来。

一旦生成了熵，就在熵上使用SHA256函数创建哈希。
检索哈希的前8位，这是校验和。
助记词是熵加上校验和的结果。

校验和确保恢复短语的准确性的验证。如果没有校验和，短语中的一个错误可能导致创建一个不同的钱包，因此造成资金的损失。通过对熵使用SHA256函数并检索哈希的前8位来获得校验和。

![image](assets/image/section3/6.webp)

根据熵的大小，助记词存在不同的标准。最常用的24个单词恢复短语的标准是256位的熵。校验和的大小是通过将熵的大小除以32来确定的。

例如，256位的熵生成一个8位的校验和。然后熵和校验和的连接导致分别为128位、160位等大小。根据熵的大小，恢复短语将由12个单词组成，对于128位，15个单词对于160位，以及24个单词对于256位。

**助记词的编码：**

![image](assets/image/section3/7.webp)

最后8位对应于校验和。
每个11位段转换为十进制。
每个十进制对应BIP39上2048个单词列表中的一个单词。值得注意的是，没有任何一个单词的前四个字母的顺序是相同的。

备份24个单词的恢复短语对于保持比特币钱包的真实性至关重要。两个最常用的标准是基于128位或256位的熵和12个或24个单词的连接。添加一个密码短语是增强钱包安全性的一个额外选项。

总之，生成助记词以确保比特币钱包的安全是一个关键过程。根据熵的大小，遵循助记词的标准非常重要。备份24个单词的恢复短语对于防止任何资金损失至关重要。

## 密码短语
<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>
密码短语是一个可选的密码，可以集成到比特币钱包中以增强安全性。其使用是可选的，由用户自行决定。通过添加任意信息，与助记词短语一起，允许计算钱包的种子，从而增强其安全性。

![image](assets/image/section3/8.webp)

密码短语是用户选择的大小的一个可选的加密盐。它通过添加任意信息来提高HD钱包的安全性，这些信息与助记词短语结合后，将允许计算种子。

一旦在创建钱包时设定，就需要它来推导钱包的所有密钥。pbkdf2函数将用来从密码短语生成种子。这个种子允许推导钱包的所有子密钥对。如果您更改了密码短语，比特币钱包将完全不同。

密码短语是增强比特币钱包安全性的重要工具。它可以实现各种安全策略。例如，它可以用来创建助记词短语的副本和备份，也可以通过减轻助记词短语随机生成的风险来提高钱包的安全性。

有效的密码短语应该长（20到40个字符）且多样（包含大写字母、小写字母、数字和符号）。它不应直接与用户或其环境相关。使用随机字符序列而不是简单的单词作为密码短语更安全。

![image](assets/image/section3/9.webp)

密码短语比简单的密码更安全。理想的密码短语应该长、多样且随机。它可以增强钱包或热软件的安全性。它还可以用来创建冗余和安全的备份。

避免丢失对钱包的访问，妥善保管密码短语备份至关重要。对于HD钱包来说，密码短语是可选的。它可以用骰子或其他伪随机数生成器随机生成。不建议记住密码短语或助记词短语。

在我们的下一课中，我们将详细检查种子的功能以及从中生成的第一对密钥。请继续关注本课程以继续您的学习。我们期待很快再次见到您。

# 比特币钱包的创建
<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## 种子和主密钥的创建
<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

在本课程的这一部分，我们将探索推导分层确定性钱包（HD Wallet）的步骤，该钱包允许分层和确定性地创建和管理私钥和公钥。

![image](assets/image/section4/0.webp)

HD钱包的基础依赖于两个基本元素：助记词短语和密码短语（可选的额外密码）。它们共同构成种子，这是一个512位的字母数字序列，作为推导钱包密钥的基础。从这个种子，它可以推导比特币钱包的所有子密钥对。种子是授予访问与钱包相关的所有比特币的钥匙，无论您是否使用密码短语。

![image](assets/image/section4/1.webp)
为了获取种子，钱包使用了pbkdf2函数（基于密码的密钥推导函数2）结合助记词和密码短语。pbkdf2的输出是一个512位的种子。

从种子开始，可以使用HMAC SHA-512（基于哈希的消息认证码安全哈希算法512）算法确定主私钥和链码。这个算法需要一个消息和一个密钥作为输入来生成结果。主私钥是从种子和短语“Bitcoin SEED”计算出来的。这个短语对所有HD钱包的所有推导都是相同的，以便确保钱包间的一致性。

最初，SHA-512函数未经在比特币协议中实施，因此其使用HMAC SHA-512的函数。使用HMAC SHA-512与短语“Bitcoin SEED”限制了用户生成特定于比特币的钱包。HMAC SHA-512的结果是一个512位的数字，分为两个部分：最左边的256位代表主私钥，而最右边的256位代表主链码。

![image](assets/image/section4/2.webp)

主私钥是钱包中所有未来密钥的父密钥，而主链码则参与子密钥的推导。重要的是要注意，没有知道父密钥对的相应链码，就不可能推导出子密钥对。

钱包中的密钥对由一个私钥、一个公钥和一个链码组成。链码在子密钥的推导中引入了一个随机性源，并隔离每个密钥对以防止任何信息泄露。
需要注意的是，主私钥是从种子推导出的第一个私钥，与钱包的扩展密钥没有任何联系。

在下一课中，我们将详细探讨扩展密钥，如xPub、xPRV、zPub，并了解它们的用途以及它们是如何构建的。

## 扩展密钥
<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

在本课的这一部分，我们将研究扩展密钥（xPub、zPub、yPub）及其前缀，这些在分层确定性钱包（HD Wallet）中推导子密钥时扮演着重要的作用。

![image](assets/image/section4/3.webp)

扩展密钥与主密钥不同。一个HD钱包生成一个助记词和一个种子来获取主密钥和主链码。扩展密钥用于推导子密钥，并且需要父密钥和相应的链码。一个扩展密钥结合了这两部分信息以简化推导过程。

![image](assets/image/section4/4.webp)

扩展公钥只能推导普通子公钥，而扩展私钥可以推导子公钥和私钥，无论是通过普通推导还是加固推导。加固推导是从父私钥推导，而普通推导对应于来源于父公钥推导。

使用带有XPUB前缀的扩展密钥允许推导新地址而不必回到相应的私钥，从而提供更佳的安全性。与扩展密钥相关的元数据提供了关于它们在密钥层次结构中的角色和位置的重要信息。
扩展密钥可通过特定的前缀（XPRV、XPUB、YPUB、ZPUB）来识别，这些前缀表明它是扩展私钥还是公钥，以及其特定用途。与扩展密钥相关联的元数据包括版本（前缀）、深度、父密钥指纹、索引和有效载荷（链码和父密钥）。
![image](assets/image/section4/5.webp)

版本对应于密钥的类型：xpub、xprv等。

深度表示从主密钥到父子密钥之间的推导次数。

父指纹是父密钥的哈希160的前4个字节。
索引是用于生成扩展密钥的配对编号，其在同一深度的密钥（兄弟密钥）中使用。例如，如果我们想推导我们的第三个账户的xpub，其索引将是2（因为索引从0开始）。

有效载荷由链码（32字节）和父密钥（33字节）组成。

压缩公钥的大小为33字节，而原始公钥为512位。压缩公钥保留与原始密钥相同的信息，但其大小更小。扩展密钥的大小为82字节，其前缀通过转换为十六进制在base 58中表示。校验和使用HASH256哈希函数计算。

![image](assets/image/section4/6.webp)

增强的推导从2的幂次方的索引开始（2^31）。值得注意的是，最常用的前缀是xpub和zpub，分别对应于传统标准以及segwit v1和segwit v0。

在我们的下一课中，我们将专注于使用关于扩展密钥和钱包的主密钥所获得的知识来推导子密钥对。

## 子密钥对的推导
<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

作为提醒，我们已经讨论了种子和主密钥的计算，这是分层组织和HD（分层确定性）钱包推导的首要元素。种子长度为128到256位，随机生成或来自秘密短语。它在所有其他密钥的推导中起到决定性作用。主密钥是从种子推导的第一个密钥，它允许推导所有其他子密钥对。

主链码在从种子恢复钱包时起着重要作用。应该注意的是，所有从同一种子推导的密钥将具有相同的主链码。

![image](assets/image/section4/7.webp)

HD钱包的分层组织和推导提供了更加有效的密钥和钱包结构管理。扩展密钥允许使用数学计算和特定算法从父密钥对推导子密钥对。
有不同类型的子密钥对，包括加固密钥和普通密钥。扩展公钥只允许推导普通子公钥，而扩展私钥允许推导所有子密钥，无论是公钥还是私钥，无论它们是在普通模式还是加固模式下。每个密钥对都有一个索引，使它们之间相互区分。

![image](assets/image/section4/8.webp)
生成子密钥对使用的是HMAC-SHA512函数，该函数使用父密钥与索引和与密钥对关联的链码串联起来。普通子密钥的索引范围从0到2的31次方减1（2^31-1)，而加固子密钥的索引范围从2的31次方到2的32次方减1(2^32-1)。

![image](assets/image/section4/9.webp)

![image](assets/image/section4/10.webp)

有两种类型的子密钥对：加固对和普通对。生成子密钥的过程使用公钥生成消费条件，而私钥用于签名。扩展公钥只允许生成普通子公钥，而扩展私钥允许以普通或加固模式生成所有子密钥，包括公钥和私钥。

![image](assets/image/section4/11.webp)
![image](assets/image/section4/12.webp)

加固推导使用父私钥，而普通推导使用父公钥。加固推导使用HMAC-SHA512函数，而普通推导使用512位摘要。通过将子私钥与椭圆曲线生成器相乘，我们可算出子公钥。

![image](assets/image/section4/13.webp)
![image](assets/image/section4/14.webp)

层次化地确定性地推导许多密钥对，允许创建一个树状结构用于层次化推导。在本培训的下一课中，我们将研究分层确定性钱包（HD Wallet）的结构以及推导路径，特别关注推导路径符号。

## 钱包结构和推导路径
<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

在本章中，我们将研究分层确定性钱包（HD Wallet）中推导树的结构。我们已经探讨了种子计算、主密钥和子密钥对的推导。现在，我们将专注于钱包内的密钥组织。

HD Wallet使用深度层来组织密钥。每一次从父对到子对的推导对应一个深度层。

![image](assets/image/section4/15.webp)

- 深度为0对应于主密钥和主链码。

- 深度为1用于推导特定目的的子密钥，由索引决定。目的遵循BIP 84和Segwit v0/v1标准。

- 深度为2允许区分不同加密货币或网络的账户。这允许根据不同的资金来源组织钱包。对于比特币，索引将是0。

- 深度为3用于将钱包组织成不同的账户，提供更清晰、更有组织的结构。

- 深度为4对应于外部和内部链，这些链用于打算公开通信的地址。索引0与外部链关联，而索引1与内部链关联。每个账户有两条链：外部链（0）和内部链（1）。深度为4还用于管理多签名钱包中的脚本类型。

- 深度为5用于标准钱包中的接收地址。在下一节中，我们将更详细地检查子密钥对的推导。

![image](assets/image/section4/16.webp)

对于每个深度层，我们使用索引来区分子密钥对。
没有带撇号的索引对应于实际使用的索引，而带撇号的索引对应于实际索引 + 2^31。加固推导使用的索引范围是从2^31到2^32-1。例如，索引44'对应于实际索引2^31 + 44。
为了生成特定的接收地址，我们从主密钥和主链代码推导出一个子密钥对。然后，我们使用索引来区分在同一深度的不同子密钥对。

扩展密钥，如XPUB，允许您与许多人共享您的钱包。推导路径用于区分外部链（意图共享的地址）和内部链（找零地址）。

在下一章中，我们将研究接收地址，它们的使用优势，以及构建它们所涉及的步骤。

# 什么是比特币地址？
<partId>81ec8d17-f8ee-5aeb-8035-d370866f4281</partId>

## 比特币地址
<chapterId>0a887ed8-3424-5a52-98e1-e4b406150475</chapterId>

在本章中，我们将探讨接收地址，这在比特币系统中扮演着至关重要的角色。它们允许在交易中接收资金，并且是从私钥和公钥对生成的。尽管存在一种被称为Pay2PublicKey的脚本类型，其允许将比特币锁定到公钥上，但用户通常更喜欢使用接收地址而不是这种脚本。

![image](assets/image/section5/0.webp)

当接收者想要接收比特币时，他们会提供一个接收地址给发送者，而不是他们的公钥。实际上，地址是公钥的哈希值，具有特定的格式。公钥是通过在椭圆曲线上进行点加和点倍加等数学运算，从子私钥推导出来的。

![image](assets/image/section5/1.webp)

重要的是要注意，从地址到公钥，或从公钥到私钥都是不可能逆转的。使用地址减小了公钥信息的大小，最初是512位。

比特币地址的大小已经减小，以便于使用。它们有一个校验和，可以检测打字错误并减少丢失比特币的风险。另一方面，公钥没有校验和，这意味着打字错误可能导致相应资金的损失。

地址还在公共和私人信息之间提供了第二层安全保障，使得控制私钥变得更加困难。

我们强烈建议，您应该使用每个地址一次。重复使用相同的地址会带来隐私问题，所以，我们建议您避免这种做法。

每一个比特币地址具有不同的前缀。例如，BC1Q前缀对应于Segwit V0地址，BC1P前缀对应于Taproot/Segwit V1地址，前缀1和3与Pay2PublicKeyH/Pay2ScriptH（传统）地址相关联。在下一课中，我们将逐步解释如何从公钥推导出地址。

## 如何创建比特币地址？
<chapterId>6dee7bf3-7767-5f8d-a01b-659b95cfe0a5</chapterId>

在本章中，我们将讨论比特币交易的接收地址的构建。接收地址是压缩公钥的字母数字表示。将公钥转换为接收地址涉及几个步骤。

### 第一步骤：公钥的压缩
![image](assets/image/section5/14.webp)
地址是由子公钥推导出来的。

公钥是椭圆曲线上的一个点。由于椭圆曲线的对称性，椭圆曲线上的一个点将有一个x坐标，与之相关联的y值只有两个可能：正或负。
然而，在比特币协议中，我们处理的是有限集合的正整数，而不是实数集合。为了区分y的两个可能值，只需指明y是偶数还是奇数即可。

公钥的压缩将其大小从520位减少成264位。

我们使用前缀0x02表示偶数y，0x03表示奇数y。这就是公钥的压缩形式。

### 第二步骤：压缩公钥的哈希处理

![image](assets/image/section5/3.webp)

压缩公钥的哈希处理是使用SHA256函数进行的。然后对摘要应用RIPEMD160函数。

### 第三步骤：有效载荷 = 地址有效载荷

![image](assets/image/section5/4.webp)

RIPEMD160(SHA256(K))的二进制摘要将用来形成一些5位的组。每组将被转换成十六进制和/或十进制的数字。

### 第四步骤：添加元数据以使用BCH程序计算校验和

![image](assets/image/section5/5.webp)

对于传统地址，我们使用双重SHA256哈希生成地址校验和。然而，对于Segwit V0和V1地址，我们依赖于BCH校验和技术来确保错误检测。BCH程序能够以极低的错误概率建议和纠正错误。目前，BCH程序用于检测和建议进行的修改，但它不会代表用户自动执行这些修改。

BCH程序需要多个输入信息，包括需要扩展的HRP（Human Readable Part，人类可读部分）。扩展HRP涉及根据它们的ASCII码以二进制形式编码每个字母。然后，取结果的每个字母的前3位并转换成十进制（图中以蓝色表述）。插入一个分隔符0。然后将每个字母之前转换为基数10的后续5位连接起来（图中以黄色表述）。

以十进制形式扩展HRP允许分离每个字符的最后五位，从而加强校验和。

Segwit V0版本由代码00表示，"payload"以十进制形式表示，标志为黑色。这之后是用于校验和的六个保留字符。

### 第五步骤：使用BCH程序计算校验和

![image](assets/image/section5/6.webp)

此后，其将把包含元数据的输入提交给BCH程序以获取以十进制形式的校验和。

这里我们有了校验和。

### 第六步骤：地址构建和转换为Bech32

![image](assets/image/section5/7.webp)

版本、有效载荷和校验和的连接允许构建地址。然后使用对应表将十进制字符转换为Bech32字符。Bech32字母表包括所有字母数字字符，除了1、b、i和o，以避免任何混淆。

### 第七步骤：添加HRP和分隔符

![image](assets/image/section5/8.webp)

粉色的部分是校验和。
在黑色部分，有效载荷 = 公钥的哈希值。蓝色部分为版本号。

一切都已被转换为Bech32格式，然后为比特币已添加了'bc'，和'1'作为分隔符，这就是比特币地址。

# 进一步了解
<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## 通过128次掷骰子来创建种子！
<chapterId>0f4d40a7-cf0e-5faf-bc4d-691486771ac1</chapterId>

创建助记词是保护您的加密货币钱包的关键步骤。有几种生成助记词的方法，但我们将重点介绍使用骰子手动生成的方法。需要注意的是，这种方法不适用于高价值的钱包。建议使用开源软件或硬件钱包来生成助记词。为了创建助记词，我们将使用骰子生成二进制信息。目标是理解创建助记词的过程。

**第一步骤 - 准备：**
确保您有一个无痕Linux发行版，如Tails OS，安装在USB密钥上以增加安全性。请注意，本教程不应用于创建主钱包。
**第二步骤 - 生成随机二进制数：**
我们将使用骰子生成二进制信息。掷骰子128次，并记录每个结果（奇数为1，偶数为0）。

**第三步骤 - 整理二进制数字：**
将得出的二进制数字整理成11位数的行，以便于进一步计算。第十二行应该只有7位数字。

**第四步骤 - 计算校验和：**
第十二行的最后4位对应于校验和。为了计算校验和，我们需要使用Linux发行版的终端。建议使用[TailOs](https://tails.boum.org/index.fr.html)，这是一个从USB密钥启动的无痕发行版。一旦在您的终端上，输入命令`echo <binary number> | shasum -a 254 -0`。将`<binary number>`替换为您的128个零和一的列表。输出是一个十六进制的哈希。记下这个哈希的第一个字符，并将其转换为二进制。您可以使用这个[表格](https://www.educative.io/answers/decimal-binary-and-hex-conversion-table)来获取帮助。将二进制校验和（4位数字）添加到您的表格的第十二行。

**第五步骤 - 转换为十进制：**
为了找出与您每一行相关联的单词，您首先需要将每个11位的序列转换为十进制。在这里，您不能使用在线转换器，因为这些位代表您的助记词短语。因此，您需要使用计算器和以下技巧进行转换：每个位与2的幂相关联，所以从左到右，我们有11个等级，对应于1024、512、256、128、64、32、16、8、4、2、1。要将您的11位序列转换为十进制，只需加上包含1的等级。例如，对于序列00110111011，这对应于以下加法：256 + 128 + 32 + 16 + 8 + 2 + 1 = 443。现在您可以将每行转换为十进制。在转换为单词之前，因为BIP39单词列表的索引从1开始而不是0，所以给所有行加上+1。

**第六步骤 - 生成助记词短语：**
首先打印[2048个单词的列表](https://seedxor.com/files/wordlist.pdf)以在您的十进制数字和BIP39单词之间转换。这个列表的独特之处在于其中的任何单词具有不同的前4位字母。然后，寻找与每行的十进制数字相关联的单词。

**第七步骤 - 助记词短语测试：**
立即在Sparrow Wallet上测试您的助记词短语，其通过创建一个钱包进行。如果您收到一个无效校验和错误，那大概率您做了计算错误。您可以通过返回到步骤4并在Sparrow Wallet上再次测试来纠正这个错误。瞧！您刚刚已通过128次骰子掷骰创建了一个新的比特币钱包。

生成助记词短语是保护您的加密货币钱包的重要过程。我们建议使用更安全的方法，例如使用开源软件或硬件钱包来生成助记词短语。然而，完成这个项目有助于更好地理解我们如何从一个随机数创建比特币钱包。

## 特别收录：Théo Pantamis 的采访
<chapterId>39f0ec5a-e258-55cb-9789-bc46d314d816</chapterId>

比特币协议上另一个广泛使用的加密方法是数字签名方法。

![video](https://youtu.be/c9MvtGJsEvY?si=bQ1N5NCd6op0G6nW)


## 给我们关于这门课程的反馈
<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>
<isCourseReview>true</isCourseReview>

## 期末考试
<chapterId>a53ea27d-0f84-56cd-b37c-a66210a4b31d</chapterId>
<isCourseExam>true</isCourseExam>


## 结论和结束
<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

### 感谢并继续探索

我们衷心感谢您完成了Crypto 301课程。我们希望这次经验对您来说是丰富和有教育意义的。我们涵盖了许多令人兴奋的领域，从数学到密码学，再到比特币协议的工作原理。

如果您想更深入地了解这个主题，我们有额外的资源提供给您。我们进行了与Théo Pantamis和Loïc Morel的独家访谈，他们是密码学领域的两位知名专家。这次访谈深入探讨了该主题的各个方面，并提供了有趣的角度。

请随意观看这次采访，继续探索密码学的巧妙领域。我们希望它对您的旅程耗用并且能够启发您。再次，感谢您在整个课程中的参与和投入。

### 支持我们
本课程以及本大学的所有内容都是由我们的社区免费提供给您的。为了支持我们，您可以将其分享给他人，成为大学的会员，甚至通过GitHub为其发展做出贡献。我代表整个团队向您表示感谢！

### 评价课程
一个针对培训的评分系统将很快整合到这个新的E-learning平台上！在此期间，非常感谢您参加本课程，如果您喜欢它，请您与他人分享。
