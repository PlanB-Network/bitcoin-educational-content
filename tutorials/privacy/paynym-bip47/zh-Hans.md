---
name: BIP47 - PayNym

description: PayNym的工作原理
---
***警告：** 继Samourai Wallet创始人于4月24日被逮捕且其服务器被查封后，未拥有自己Dojo的用户将无法再使用该应用程序。BIP47仍然可以在Sparrow Wallet上供所有用户使用，**只有拥有Dojo的用户才能在Samourai Wallet上使用**。*

_我们正在密切关注此案件的发展以及与之相关工具的发展情况。请放心，一旦有新信息，我们将更新本教程。_

_本教程仅供教育和信息目的使用。我们不支持或鼓励使用这些工具进行犯罪活动。每个用户都有责任遵守其管辖区的法律。_

---

> “他太大了，”他们都说，而那只生来就长着距离、自以为是皇帝的火鸡，像一艘张满帆的船一样膨胀起来，怒气冲冲地直奔他而去，眼睛红得像火一样。可怜的小鸭子不知道是该站稳脚跟还是逃跑，因为被院子里所有的鸭子鄙视，他感到非常不幸。

![BIP47, 丑小鸭插图](assets/1.webp)

比特币协议上最重要的问题之一是地址重用。网络的透明性和分布性使这种做法对用户隐私极为危险。为了避免与此相关的问题，建议对钱包的每一笔新进款使用一个新的空白接收地址，这在某些情况下可能难以实现。

这种妥协与白皮书一样古老。萨托希在2008年末发表的作品中就已经警告我们这一风险：

> “作为一个额外的防火墙，每一笔交易都应使用一个新的密钥对，以防止它们被链接到一个共同的所有者。”

有许多解决方案可用于接收多笔支付而无需地址重用。它们中的每一个都有其妥协和缺点。在所有这些解决方案中，有一个是[BIP47](https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki)，这是Justus Ranvier在2015年开发的提案，它允许生成可重用的支付代码。其目标是使多笔交易能够发送给同一个人而不重用地址。

最初，这个提案被社区的一部分人轻视，从未被添加到比特币核心中。然而，一些软件仍然选择自行实现它。例如，Samourai Wallet开发了自己的BIP47实现：PayNym。如今，这种实现在智能手机上的Samourai Wallet以及PC上的[Sparrow Wallet](https://sparrowwallet.com/)上都可用。

随着时间的推移，Samourai为PayNym直接编程了新功能。现在，有一个基于PayNym和BIP47优化用户隐私的完整工具生态系统可用。
在本文中，您将发现BIP47和PayNym的原理，这些协议的机制，以及由此产生的实际应用。我将只讨论当前用于PayNym的BIP47的第一版本，但第2、3和4版本的工作方式几乎相同。
唯一的主要区别在于通知交易。版本1使用一个简单的地址和OP_RETURN进行通知，版本2使用多签名脚本（bloom-multisig）和OP_RETURN，而版本3和4直接使用多签名脚本（cfilter-multisig）。因此，本文讨论的机制，包括研究的加密方法，适用于所有四个版本。迄今为止，Samourai Wallet和Sparrow上的PayNym实现使用的是BIP47的第一个版本。

## 摘要：

1- 地址重用问题。

2- BIP47和PayNym的原则。

3- 教程：使用PayNym。

- 使用Samourai Wallet构建BIP47交易。
- 使用Sparrow Wallet构建BIP47交易。

4- BIP47的工作原理。

- 可重用支付代码。
- 加密方法：建立在椭圆曲线上的Diffie-Hellman密钥交换（ECDH）。
- 通知交易。
- 构建通知交易。
- 接收通知交易。
- BIP47支付交易。
- 接收BIP47支付并派生私钥。
- 退还BIP47支付。

5- PayNym的衍生用途。

6- 我对BIP47的个人看法。

## 地址重用问题。

接收地址用于接收比特币。它通过对公钥进行哈希处理并应用特定格式生成。因此，它允许在硬币上创建一个新的支付条件以更改其所有者。

> 要了解更多关于生成接收地址的信息，我推荐阅读本文的最后一部分：比特币钱包 - 摘自[ebook Bitcoin Démocratisé 2](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2#viewer-epio7)。

此外，你可能已经从一个知识渊博的比特币用户那里听说过，接收地址是一次性使用的，你应该为钱包中的每一笔新进款项生成一个新地址。好的，但为什么呢？
从根本上讲，地址重用并不直接危及你的资金。椭圆曲线加密的使用允许你向网络证明你拥有私钥而不泄露该密钥。因此，你可以在同一个地址上锁定多个不同的UTXOs（未花费交易输出）并在不同时间花费它们。如果你不泄露与该地址关联的私钥，没有人可以访问你的资金。地址重用的问题更多的是与隐私相关。

正如引言中提到的，比特币网络的透明性和分布性意味着任何有权访问节点的用户都可以观察到支付系统的交易。结果，他们可以看到不同地址的不同余额。然后，中本聪提到了为钱包中的每一笔新进款项生成新的密钥对，因此新地址的可能性。目标是在用户的身份与其某个密钥对之间建立关联的情况下增加一个额外的防火墙。

今天，随着链分析公司的出现和KYC（了解你的客户）的发展，使用空白地址不再是一个额外的防火墙，而是对任何稍微关心自己隐私的人来说都是一项义务。

追求隐私不是比特币极客的舒适或幻想。这是一个直接影响你的个人安全和资金安全的具体参数。为了帮助你理解这一点，这里有一个非常具体的例子：
- 鲍勃通过定投（DCA）购买比特币，这意味着他定期购买少量比特币以平均他的入场价格。鲍勃系统性地将购买的资金发送到同一个接收地址。他每周购买0.01比特币，并发送到这个相同的地址。两年后，鲍勃在这个地址上累积了整整一个比特币。
- 街角的面包师接受比特币支付。鲍勃兴奋地用satoshi去买他的法棍面包。为了支付，他使用了锁定在他地址上的资金。他的面包师现在知道他拥有一个比特币。这个重要的金额可能会引起他人的嫉妒，鲍勃将来可能面临身体攻击的风险。

地址重用允许观察者无可否认地链接您不同的UTXOs，有时甚至链接您的身份和您的整个钱包。
这就是为什么大多数比特币钱包软件在您点击“接收”按钮时自动生成一个新的接收地址。对于普通用户来说，养成使用新地址的习惯并不是一个大麻烦。然而，对于在线业务、交易所或捐赠活动来说，这个限制很快就会变得难以管理。
对于这些组织来说，有许多解决方案。它们每一个都有其优点和缺点，但到目前为止，正如我们稍后将看到的，BIP47确实从其他方案中脱颖而出。

在比特币中，地址重用的问题远非微不足道。正如你在下面从oxt.me网站上看到的图表中所见，比特币用户的整体地址重用率目前为52%：
来自OXT.me的图表显示了比特币网络上整体地址重用率的演变。

![image](assets/2.webp)

信用：OXT

这些重用的大多数来自交易所，出于效率和便利的原因，它们多次重用相同的地址。到目前为止，BIP47将是遏制交易所中这一现象的最佳解决方案。这将有助于降低整体地址重用率，而不会给这些实体带来太多的摩擦。

这个全球性的措施贯穿整个网络，特别是在这种情况下非常相关。实际上，地址重用不仅是从事这种做法的人的问题，也是与他们进行交易的任何人的问题。在比特币上的隐私损失就像病毒一样，从用户传播给用户。研究整个网络交易的全球性措施，让我们能够理解这一现象的程度。

## BIP47和PayNym的原则。

BIP47旨在提供一种简单的方式来接收多次支付而不重用地址。其操作基于使用可重用的支付代码。

因此，多个发送者可以向另一个用户的单个可重用支付代码发送多次支付，而无需接收者为每一笔新交易提供一个新的空白地址。

用户可以自由分享他们的支付代码（在社交网络上，在他们的网站上...）而不会像常规接收地址或公钥那样有丧失隐私的风险。
为了进行交易，两个用户必须拥有一个实现了BIP47的比特币钱包，例如Samourai Wallet或Sparrow Wallet上的PayNym。两个用户的支付代码的关联将在他们之间建立一个秘密通道。为了正确建立这个通道，发送者必须在比特币区块链上进行一笔交易：通知交易（我稍后会更详细地解释这一点）。

两个用户的支付代码的关联生成了共享的秘密，这些秘密本身生成了大量独特的比特币接收地址（确切地说是2^32个）。因此，实际上，使用BIP47的支付并不是发送到支付代码，而是发送到从参与方的支付代码派生出来的完全正常的地址。
支付代码作为一个虚拟标识符，源自钱包种子。在HD钱包派生结构中，支付代码位于深度3，即钱包账户级别。
![image](assets/3.webp)

其派生目的在BIP47中被标记为47'（0x8000002F）。例如，一个可重用支付代码的派生路径为：

> m/47'/0'/0'/

为了让你了解支付代码的样子，这是我的：

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

它也可以被编码为二维码以便于通信：

![image](assets/4.webp)

至于PayNym机器人，那些你在Twitter上看到的机器人，它们只是你支付代码的视觉表现，由Samourai Wallet创建。它们通过哈希函数生成，这使得它们几乎是唯一的。这是我的及其标识符：

> +throbbingpond8B1

![image](assets/5.webp)

这些机器人没有任何真正的技术用途。相反，它们通过创建一个虚拟视觉身份来促进用户之间的互动。

对于用户来说，使用PayNym实现进行BIP47支付的过程极其简单。让我们假设Alice想要向Bob发送支付：

1. Bob分享他的二维码或直接分享他的可重用支付代码。他可以将其放置在他的网站上，在他的各种公共社交网络上，或通过其他通信方式发送给Alice。
2. Alice打开她的Samourai或Sparrow软件，扫描或粘贴Bob的支付代码。
3. Alice将她的PayNym与Bob的链接起来（英文中为"Follow"）。这个操作是在链下完成的，完全免费。

4. Alice将她的PayNym与Bob的连接起来（英文中为"Connect"）。这个操作是在链上完成的。Alice必须支付交易挖矿费用以及Samourai上服务的固定费用15,000 sats。Sparrow上免除服务费。这一步骤被称为通知交易。

5. 一旦通知交易被确认，Alice就可以创建一个BIP47支付交易给Bob。她的钱包将自动生成一个新的空白接收地址，只有Bob拥有私钥。

执行通知交易，即连接她的PayNym，是进行BIP47支付的必要前提。然而，一旦完成，发送方可以向接收方进行多次支付（准确地说是2^32次），而无需执行新的通知交易。

你可能已经注意到，将PayNyms链接在一起有两种不同的操作："follow"和"connect"。连接操作（"connect"）对应于BIP47通知交易，这只是一个带有通过OP_RETURN输出传输的某些信息的比特币交易。因此，它有助于在两个用户之间建立加密通信，以产生生成新的空白接收地址所需的共享秘密。

另一方面，链接操作（"follow"或"relier"）允许在Soroban上建立链接，Soroban是一个基于Tor的加密通信协议，由Samourai团队特别开发。

总结：
- 将两个PayNym链接（"follow"）是完全免费的。这有助于建立链下加密通信，特别是用于使用Samourai的协作交易工具（Stowaway或StonewallX2）。这一操作是特定于PayNym的，并未在BIP47中描述。
- 连接两个PayNym会产生成本。这涉及执行通知交易以启动连接。成本包括任何服务费、交易挖矿费，以及发送到接收者的通知地址的546 sats，以通知他们隧道开启。这一操作与BIP47有关。一旦完成，发送者可以向接收者进行多次BIP47支付。

为了连接两个PayNym，它们必须已经被链接。

## 教程：使用PayNym。

现在我们已经了解了理论，让我们一起研究实践。下面的教程的想法是将我的PayNym在我的Sparrow钱包上与我的Samourai钱包上的PayNym链接。第一个教程向您展示如何使用Samourai到Sparrow的可重用支付代码进行交易，第二个教程描述了从Sparrow到Samourai的相同机制。

> 我在Testnet上进行了这些教程。这些不是真正的比特币。

### 使用Samourai Wallet构建BIP47交易。

首先，你显然需要Samourai Wallet应用程序。你可以直接从Google Play商店下载，或者从官方Samourai网站上获取APK文件。

一旦钱包初始化，如果你还没有，通过点击右下角的加号（+），然后点击"PayNym"来请求你的PayNym。

进行BIP47支付的第一步是从我们的接收者那里检索可重用支付代码。然后，我们将能够与他们连接并随后链接：

![video](assets/6.mp4)

一旦通知交易被确认，我可以向我的接收者发送多次支付。每一笔交易都将自动使用一个新的空白地址进行，接收者拥有该地址的密钥。接收者不需要采取任何行动，一切都在我的一方计算。

以下是在Samourai Wallet上进行BIP47交易的方法：

![video](assets/7.mp4)

### 使用Sparrow Wallet构建BIP47交易。

就像使用Samourai一样，你显然需要拥有Sparrow软件。这可以在你的电脑上获得。你可以从他们的[官方网站](https://sparrowwallet.com/)下载。

在将软件安装到你的机器上之前，确保验证开发者的签名和下载软件的完整性。

创建一个钱包并通过点击顶部栏中的"Tool"菜单中的"Show PayNym"来请求你的PayNym：

![image](assets/8.webp)

然后，你需要将你的PayNym与接收者的PayNym链接和连接。为此，在"Find Contact"窗口中输入他们的可重用支付代码，跟随他们，然后通过点击"Link Contact"执行通知交易：

![image](assets/9.webp)

一旦通知交易被确认，你就可以向可重用支付代码发送支付了。以下是如何做到这一点：

![video](assets/10.mp4)

现在我们已经能够研究PayNym实现BIP47的实践方面，让我们看看所有这些机制是如何工作的，以及使用了什么加密方法。
为了研究BIP47的机制，理解分层确定性（HD）钱包的结构、派生子密钥对的机制以及椭圆曲线密码学的原理是至关重要的。幸运的是，你可以在我的博客上找到理解这部分所需的所有信息：
- [理解比特币钱包的派生路径](https://www.pandul.fr/post/comprendre-les-chemins-de-d%C3%A9rivation-d-un-portefeuille-bitcoin)

- [比特币钱包 - 摘自电子书《比特币民主化2》](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2)

### 可重用支付代码。

如本文第二部分所解释的，可重用支付代码位于HD钱包的第三层深度。它在位置和结构以及角色上与xpub有些相似。

以下是构成80字节支付代码的不同部分：

- 字节0：版本。如果使用BIP47的第一个版本，此字节将等于0x01。

- 字节1：位字段。此空间保留用于在特定使用情况下提供额外指示。如果简单使用PayNym，此字节将等于0x00。

- 字节2：y奇偶性。此字节根据我们公钥的y坐标值的奇偶性（偶数或奇数）指示0x02或0x03。有关此做法的更多信息，请阅读本文“地址派生”部分的第一步。

- 从字节3到字节34：x值。这些字节指示我们公钥的x坐标。x和y奇偶性的连接给出了我们的压缩公钥。

- 从字节35到字节66：链码。此空间保留用于与上述公钥关联的链码。

- 从字节67到字节79：填充。此空间保留用于可能的未来发展。对于版本1，我们简单地用零填充它以达到80字节，这是OP_RETURN输出的数据大小。

以下是我在前一节中介绍的可重用支付代码的十六进制表示，颜色对应于上述字节：
接下来，你还需要添加前缀字节"P"以快速识别我们正在处理支付代码。此字节为0x47。

> 0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000

最后，我们使用HASH256计算此支付代码的校验和，这意味着使用SHA256函数进行双重散列。我们检索此摘要的前四个字节并在末尾连接它们（以粉色表示）。
支付代码已准备就绪，现在我们只需要将其转换为Base 58：

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

如您所见，这种构造与“xpub”类型的扩展公钥的结构非常相似。

在获取我们的支付代码的过程中，我们使用了一个压缩公钥和一个链码。这两个元素是从钱包种子按照以下派生路径进行确定性和层次化派生的结果：m/47'/0'/0'/
具体来说，为了获取可重用支付代码的公钥和链码，我们将从种子计算出主私钥，然后派生出一个索引为47 + 2^31（强化派生）的子对。然后，我们再派生出两个索引为2^31（强化派生）的子对。

> 如果您想了解更多关于在层次确定性比特币钱包中派生子密钥对的信息，我推荐参加CRYPTO301课程。

### 加密方法：椭圆曲线Diffie-Hellman密钥交换（ECDH）。

BIP47核心使用的加密方法是ECDH（椭圆曲线Diffie-Hellman）。这个协议是经典Diffie-Hellman密钥交换的一个变种。

Diffie-Hellman的第一个版本是一个在1976年提出的密钥协议，它允许两个各自拥有一对公钥和私钥的方，通过在不安全的通信渠道上交换信息来确定一个共享秘密。

![image](assets/11.webp)

这个共享秘密（红色钥匙）随后可以用于其他任务。通常，这个共享秘密可以用来加密和解密在不安全网络上的通信：

![image](assets/12.webp)

为了实现这种交换，Diffie-Hellman使用模运算来计算共享秘密。这里是一个简化的解释：

- Alice和Bob同意一个共同的颜色，这个例子中是黄色。这个颜色是众所周知的。它是公开信息。

- Alice选择一个秘密颜色，这个例子中是红色。她将两种颜色混合，结果是橙色。

- Bob选择一个秘密颜色，这个例子中是青色。他将两种颜色混合，结果是天蓝色。

- Alice和Bob可以交换他们得到的颜色：橙色和天蓝色。这种交换可以通过不安全的网络进行，并且可以被攻击者观察到。

- Alice将从Bob那里收到的天蓝色与她的秘密颜色（红色）混合。她得到了棕色。

- Bob将从Alice那里收到的橙色与他的秘密颜色（青色）混合。他也得到了棕色。

![image](assets/13.webp)
> z等于A的b次方对p取模：
> z = A^b % p

- 作为提醒，A = g^a % p。因此：

  > z = A^b % p
  > z = (g^a)^b % p
  >
  > 根据指数运算规则：
  >
  > (x^n)^m = x^(nm)
  >
  > 因此：
  >
  > z = g^(ab) % p

在这个简化的例子中，棕色代表Alice和Bob之间共享的秘密。应该想象，在现实中，攻击者不可能分离橙色和天蓝色以获取Alice或Bob的秘密颜色。

现在，让我们研究它的实际工作原理。乍一看，Diffie-Hellman可能看起来复杂难懂。实际上，其运作原理几乎像小孩子的游戏一样简单。在详细介绍其机制之前，我将快速提醒您我们将需要的两个数学概念（顺便说一句，这些概念也在许多其他加密方法中使用）。

1. 质数是只有两个除数的自然数：1和它本身。例如，数字7是质数，因为它只能被1和7（它本身）整除。另一方面，数字8不是质数，因为它可以被1、2、4和8整除。因此，它不仅有两个除数，而且有四个整数和正除数。

2. “模”（表示为"mod"或"%"）是一种数学运算，允许两个整数返回第一个数除以第二个数的欧几里得除法的余数。例如，16 mod 5等于1。

Alice和Bob之间的Diffie-Hellman密钥交换如下进行：

- Alice和Bob确定两个共同的数字：p和g。p是一个质数。这个数字p越大，Diffie-Hellman就越安全。g是p的原根。这两个数字可以通过不安全的网络以明文形式传输，它们相当于上述简化中的黄色。Alice和Bob只需要对p和g的值完全相同。

- 一旦选择了参数，Alice和Bob各自确定一个自己的秘密随机数。Alice得到的随机数命名为a（相当于红色），Bob得到的随机数命名为b（相当于青色）。这两个数字必须保密。

- 代替交换这些数字a和b，每一方将计算A（大写）和B（大写），使得：

> A等于g的a次方对p取模：
> A = g^a % p

> B等于g的b次方对p取模：
> B = g^b % p

- 这些数字A（相当于橙色）和B（相当于天蓝色）将在双方之间交换。交换可以通过不安全的网络以明文形式完成。

- Alice，现在知道B，将计算z的值，使得：

> z等于B的a次方对p取模：
> z = B^a % p

- 作为提醒，B = g^b % p。因此：

  > z = B^a % p
  > z = (g^b)^a % p
  >
  > 根据指数运算规则：
  >
  > (x^n)^m = x^(nm)
  >
  > 因此：
  >
  > z = g^(ba) % p

- Bob，现在知道A，也将按照如下方式计算z的值：
z 等于 A 的 b 次方对 p 取模：
> z = A^b % p

因此：
> z = (g^a)^b % p
> z = g^ab % p
> z = g^ba % p

由于模运算的分配律，Alice 和 Bob 得到了相同的 z 值。这个数字代表他们的共享秘密，相当于前面解释中的棕色。他们可以使用这个共享秘密在不安全的网络上加密通信。

![Diffie-Hellman 技术操作图](assets/14.webp)

拥有 p、g、A 和 B 的攻击者将无法计算出 a、b 或 z。执行这个操作需要逆向指数运算，除了逐一尝试所有可能性之外，这是不可能做到的，因为我们是在有限域中工作。这相当于计算离散对数，它是循环有限群中指数运算的倒数。

因此，只要我们为 a、b 和 p 选择足够大的值，Diffie-Hellman 就是安全的。通常，使用 2048 位（十进制中有 600 位数字）的参数，测试所有 a 和 b 的可能性将是不切实际的。到目前为止，对于这种大小的数字，算法被认为是安全的。

这正是 Diffie-Hellman 协议的主要缺点所在。为了保证安全，算法必须使用大数字。因此，现在更倾向于使用 ECDH 算法，这是 Diffie-Hellman 的一个变种，它使用代数曲线，特别是椭圆曲线。这使我们能够在保持等效安全性的同时使用更小的数字，从而减少所需的计算和存储资源。

算法的总体原理保持不变。然而，我们将不再使用随机数 a 和通过模幂运算从 a 计算出的数 A，而是使用建立在椭圆曲线上的一对密钥。我们将不依赖模运算的分配律，而是使用椭圆曲线上的群律，特别是这一律的结合性。
如果你不了解椭圆曲线上的私钥和公钥是如何工作的，我将在本文的前六部分解释这种方法的基础知识。

简单概括，私钥是 1 到 n-1 之间的随机数（其中 n 是曲线的阶），公钥是通过从生成点开始，通过点加和加倍确定的曲线上的唯一点，如下所示：

> K = k·G

其中 K 是公钥，k 是私钥，G 是生成点。

这对密钥的一个属性是，如果你知道 k 和 G，就很容易确定 K，但如果你知道 K 和 G，目前不可能确定 k。它是一个单向函数。

换句话说，如果你知道私钥，你可以轻松计算出公钥，但如果你知道公钥，就不可能计算出私钥。这种安全性再次基于计算离散对数的不可能性。

我们将使用这个属性来调整我们的 Diffie-Hellman 算法。因此，ECDH 的操作原理如下：

- Alice 和 Bob 同意一个密码学安全的椭圆曲线及其参数。这些信息是公开的。
- 爱丽丝生成一个随机数ka，这将是她的私钥。这个私钥必须保密。她通过在选定的椭圆曲线上加点和倍点来确定她的公钥Ka。
> Ka = ka·G

- 鲍勃也生成一个随机数kb，这将是他的私钥。他计算出相应的公钥Kb。
> Kb = kb·G

- 爱丽丝和鲍勃通过不安全的公共网络交换他们的公钥Ka和Kb。

- 爱丽丝通过将她的私钥ka应用于鲍勃的公钥Kb，计算出曲线上的一个点(x, y)。
> (x, y) = ka·Kb

- 鲍勃通过将他的私钥kb应用于爱丽丝的公钥Ka，计算出曲线上的一个点(x, y)。
> (x, y) = kb·Ka

- 爱丽丝和鲍勃在椭圆曲线上获得相同的点。共享的秘密将是这个点的x坐标。

他们确实获得了相同的共享秘密，因为：
> (x, y) = ka·Kb = ka·kb·G = kb·ka·G = kb·Ka

观察不安全公共网络的潜在攻击者只能获得每一方的公钥和选定曲线参数。如前所述，这两条信息单独并不足以确定私钥，因此攻击者无法访问秘密。
ECDH是一个允许密钥交换的算法。它经常与其他加密方法一起使用，以定义一个协议。例如，ECDH在TLS（传输层安全性）的核心中使用，TLS是用于互联网传输层的加密和认证协议。TLS使用ECDHE进行密钥交换，ECDH的一个变体，其中的密钥是临时的，以提供持久的保密性。除了ECDHE，TLS还使用像ECDSA这样的认证算法、像AES这样的加密算法和像SHA256这样的哈希函数。

TLS定义了"https"中的"s"和你在互联网浏览器左上角看到的小锁图标，这保证了加密通信。所以，你在阅读这篇文章时实际上正在使用ECDH，而且你可能每天都在无意中使用它。

### 通知交易。

正如我们在前一节中发现的，ECDH是Diffie-Hellman交换的一个变体，涉及在椭圆曲线上建立的密钥对。幸运的是，我们的比特币钱包中有大量符合这一标准的密钥对！

这个想法是使用双方的分层确定性比特币钱包中的密钥对，在他们之间建立共享和临时的秘密。在BIP47中，使用ECDHE（椭圆曲线Diffie-Hellman临时）代替。

ECDHE最初在BIP47中用于传输发送方的支付代码给接收方。这就是著名的通知交易。为了使用BIP47，双方（发送支付的发送方和接收支付的接收方）需要知道彼此的支付代码。这是必要的，以便派生临时公钥，因此是专用的接收地址。
在这次交换之前，发送方在逻辑上已经知道接收方的支付代码，因为他们可以通过非链上方式获得，例如，从他们的网站或社交媒体上。然而，接收方可能不一定知道发送方的支付代码。这需要传输给他们，否则他们将无法派生他们的临时密钥，因此将无法知道他们的比特币在哪里以及如何解锁他们的资金。这可以通过非链上的另一种通信系统传输给他们，但如果钱包是从种子恢复的，这将会带来问题。的确，正如我已经提到的，BIP47地址不是从接收方的种子派生的（否则，直接使用他们的xpub之一会更好），而是一个涉及接收方支付代码和发送方支付代码的计算结果。因此，如果接收方丢失了他们的钱包并试图从他们的种子中恢复它，他们将需要拥有通过BIP47向他们发送比特币的所有人的支付代码。

如果没有这个通知交易，使用BIP47是可能的，但每个用户都需要备份他们同伴的支付代码。这种情况将保持难以管理，直到找到一种简单且有韧性的方法来创建、存储和更新这些备份。因此，在当前情况下，通知交易几乎是必须的。

除了备份支付代码的作用外，正如其名称所示，这笔交易还充当了对接收方的通知。它通知他们的客户端一个通道刚刚被打开。

在更详细地解释通知交易的技术运作之前，我想稍微谈谈隐私模型。的确，BIP47隐私模型证明了在构建这个初始交易时采取某些预防措施的合理性。

支付代码本身并不直接对隐私构成风险。与允许打破用户身份与交易之间的信息流的经典比特币模型不同，特别是通过保持公钥匿名，支付代码可以直接与一个身份关联。这不是强制的，但这种链接并不危险。

的确，支付代码并不直接派生用于接收BIP47支付的地址。相反，这些地址是通过将双方支付代码的子密钥之间应用ECDHE获得的。

因此，单独一个支付代码并不直接对隐私构成风险，因为只有通知地址是从中派生的。可以从中推断出一些信息，但通常情况下，人们无法知道你与谁进行交易。

因此，维护用户支付代码之间的严格分离至关重要。在这方面，代码的初始通信步骤是支付隐私的关键时刻，然而，它对于协议的正确运作是必须的。如果其中一个支付代码可以公开检索（例如，从网站上），第二个代码，即发送方的代码，不应该与第一个代码关联。

例如，让我们想象我想用BIP47向加拿大的一个和平抗议运动捐款：

- 这个组织已经直接在其网站或社交媒体平台上发布了其支付代码。
- 因此，这个代码与该运动相关联。

- 我检索了这个支付代码。

- 在我可以给他们发送交易之前，我必须确保他们知道我的个人支付代码，这也与我的身份相关联，因为我用它来接收来自我的社交网络的交易。

我如何将它传输给他们？如果我使用常规的通信方式发送给他们，信息可能会泄露，我可能会被识别为支持和平运动的人。
通知交易绝对不是秘密传输发送方支付代码的唯一解决方案，但它通过应用多层安全措施，目前完美地履行了这一角色。
在下面的图表中，红线代表信息流必须被打断的时刻，黑色箭头代表外部观察者可以建立的不可否认的联系：

![可重用支付代码的隐私模型图](assets/15.webp)

实际上，对于比特币的经典隐私模型，完全打断密钥对与用户之间的信息流通常很困难，特别是在进行远程交易时。例如，在捐赠活动的情况下，接收方将被要求在其网站或社交媒体平台上公开一个地址或公钥。正确使用BIP47，即通过通知交易，通过ECDHE和我们将要研究的加密层解决了这个问题。

显然，比特币的经典隐私模型仍然在由两个支付代码关联生成的临时公钥级别得到遵守。这两种模型是相互依赖的。我只是想在这里强调，与使用公钥接收比特币的经典用法不同，支付代码可以与身份关联，因为“Bob正在与Alice进行交易”的信息在另一个时刻被打断。支付代码用于生成支付地址，但仅通过观察区块链，不可能将BIP47支付交易与用于进行交易的支付代码关联起来。

### 通知交易的构建。

现在，让我们看看这个通知交易是如何工作的。假设Alice想要使用BIP47向Bob发送资金。在我的例子中，Alice充当发送方，Bob充当接收方。Bob已经在他的网站上发布了他的支付代码，所以Alice已经知道了Bob的支付代码。

1. Alice通过ECDH计算一个共享密钥：

- 她从位于与她支付代码不同分支的HD钱包中选择一对密钥。注意，这对密钥不应该容易与Alice的通知地址或Alice的身份关联起来（见前一节）。
- Alice选择这对密钥中的私钥。我们将其称为"a"（小写）。

> a

- Alice检索与Bob的通知地址关联的公钥。这个公钥是从Bob的支付代码派生的第一个子项（索引0）。我们将这个公钥称为"B"（大写）。与这个公钥关联的私钥称为"b"（小写）。"B"是通过椭圆曲线上的点加和加倍运算，用"b"（私钥）和"G"（生成点）确定的。

> B = b·G

- Alice通过点加和加倍运算，在椭圆曲线上计算一个秘密点"S"（大写），应用她的私钥"a"到Bob的公钥"B"上。

> S = a·B

- Alice计算将用于加密她的支付代码的盲化因子"f"。为此，她将使用HMAC-SHA512函数生成一个伪随机数。作为这个函数的第二个输入，她使用只有Bob能够检索的值：(x)，即之前计算的秘密点的x坐标。第一个输入是(o)，即作为这个交易输入消耗的UTXO（输出点）。

> f = HMAC-SHA512(o, x)

2. Alice将她的个人支付代码转换为基数2（二进制）。
3. 她使用这个盲因子作为密钥，对她的支付码的有效载荷进行对称加密。使用的加密算法是简单的XOR。执行的操作类似于Vernam密码，也被称为“一次性密码本”：
- Alice首先将她的盲因子分成两部分：前32字节称为"f1"，后32字节称为"f2"。所以我们有：

> f = f1 || f2

- Alice计算她的支付码的公钥（x）的x坐标的密文（x'），并分别计算她的链码（c）的密文（c'）。"f1"和"f2"作为加密密钥，使用XOR操作。

> x' = x XOR f1
>
> c' = c XOR f2

- Alice用加密后的值（x'）和（c'）替换她的支付码中公钥的横坐标（x）和链码（c）的实际值。

在继续讨论这个通知交易的技术描述之前，让我们花点时间讨论一下XOR操作。XOR是基于布尔代数的位逻辑运算符。给定两个位操作数，如果相应的位不同，则返回1；如果相应的位相同，则返回0。这是基于操作数D和E的值的XOR的真值表：

| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |

例如：

> 0110 XOR 1110 = 1000

或者：

> 010011 XOR 110110 = 100101

在ECDH中，使用XOR作为加密层是特别合理的。首先，由于这个运算符，加密是对称的。这允许接收者使用用于加密的相同密钥来解密支付码。加密和解密密钥是通过ECDH从共享秘密计算出来的。

这种对称性是由XOR运算符的交换律和结合律属性启用的：

- 其他属性：
  -> D ⊕ D = 0
  -> D ⊕ 0 = D

- 交换律：
  D ⊕ E = E ⊕ D

- 结合律：
  D ⊕ (E ⊕ Z) = (D ⊕ E) ⊕ Z = D ⊕ E ⊕ Z

- 对称性：
  如果：D ⊕ E = L
  那么：D ⊕ L = D ⊕ (D ⊕ E) = D ⊕ D ⊕ E = 0 ⊕ E = E
  -> D ⊕ L = E
接下来，这种加密方法与Vernam密码（一次性密码本）非常相似，后者是迄今为止唯一已知具有无条件（或绝对）安全性的加密算法。为了使Vernam密码具有这种特性，加密密钥必须是完全随机的，与消息大小相同，并且只能使用一次。在这里用于BIP47的加密方法中，密钥确实与消息大小相同，盲化因子与公钥的x坐标与支付代码链代码的连接完全相同大小。这个加密密钥确实只使用了一次。然而，这个密钥不是来自完美随机源，因为它是一个HMAC。它相当于伪随机。因此，它不是Vernam密码，但方法是相似的。
让我们回到我们的通知交易构建：

4. Alice目前拥有她的支付代码和一个加密的有效载荷。她将构建并广播一个交易，该交易涉及她的公钥“A”作为输入，一个输出到Bob的通知地址，以及一个包含她的支付代码和加密有效载荷的OP_RETURN输出的交易。这个交易是通知交易。

OP_RETURN是一个操作码，它是一个将比特币交易输出标记为无效的脚本。今天，它被用来在比特币区块链上广播或锚定信息。它可以存储多达80字节的数据，这些数据被记录在链上，因此对所有其他用户可见。

正如我们在前一节中看到的，Diffie-Hellman被用来在不安全的网络上生成两个用户之间的共享秘密，这个网络可能被攻击者观察。在BIP47中，使用ECDH在比特币网络上通信，这本质上是一个被许多攻击者观察的透明通信网络。通过椭圆曲线上的Diffie-Hellman密钥交换计算出的共享秘密随后被用来加密要传输的秘密信息：发送者（Alice的）支付代码。

这是从BIP47中提取的一个图表，说明了我们刚才描述的内容：

![Diagram Alice sends her masked payment code to Bob's notification address](assets/16.webp)

信用：可重用支付代码的分层确定性钱包，Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

如果我们将这个图表与我之前描述的内容匹配：

- Alice一侧的“Wallet Priv-Key”对应于：a。

- Bob一侧的“Child Pub-Key 0”对应于：B。
- “Notification Shared Secret”对应于：f。
- “Masked Payment Code”对应于加密的支付代码，即，带有加密有效载荷的：x' 和 c'。

- “Notification Transaction”是包含OP_RETURN的交易。

让我们回顾一下我们刚刚经历的执行通知交易的步骤：

- Alice检索Bob的支付代码和通知地址。

- Alice选择属于她的HD钱包中的一个UTXO及其对应的密钥对。

- 她使用ECDH计算椭圆曲线上的一个秘密点。

- 她使用这个秘密点来计算一个HMAC，这是盲化因子。

- 她使用这个盲化因子来加密她个人支付代码的有效载荷。

- 她使用一个OP_RETURN交易输出来将掩码支付代码转移给Bob。

为了更好地理解其操作，特别是OP_RETURN的使用，让我们一起研究一个真实的通知交易。我在Testnet上执行了这样一种交易，你可以通过点击这里找到：
通过观察这笔交易，我们可以看到它有一个输入和四个输出：

- 第一个输出是包含我的掩码支付代码的OP_RETURN。

- 第二个输出的546 sats指向接收者的通知地址。

- 第三个输出的15,000 sats代表服务费，因为我使用Samourai Wallet来构建这笔交易。

- 第四个输出的两百万sats代表找零，即从我的输入中剩余的差额，返回到另一个属于我的地址。

最值得研究的显然是使用OP_RETURN的输出0。让我们更仔细地看看它包含了什么：

我们发现输出的十六进制脚本：

> 6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000

在这个脚本中，我们可以分解几个部分：
在操作码中，我们可以识别出0x6a，它指的是OP_RETURN，以及0x4c，它指的是OP_PUSHDATA1。紧跟这个操作码的字节指示了随后的有效载荷的大小。它指示的是0x50，即80字节。

接下来是带有加密有效载荷的支付代码。

这是我在这笔交易中使用的支付代码：

> 以base 58形式：
>
> PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
>
> 以base 16 (HEX)形式：
> 4701000277507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42add94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc000000000000000000000000008604e4db

如果我们将我的支付代码与OP_RETURN进行比较，我们可以看到HRP（棕色部分）和校验和（粉色部分）没有被传输。这是正常的，因为这些信息是为人类准备的。
接下来，我们可以识别（以绿色显示）版本（0x01）、位字段（0x00）和公钥奇偶性（0x02）。在支付代码的末尾，有允许填充以达到总共80字节的空字节（以黑色显示）（0x00）。所有这些元数据都是以明文（未加密）传输的。最后，我们可以观察到公钥的x坐标（以蓝色显示）和链代码（以红色显示）已被加密。这构成了支付代码的有效载荷。

### 接收通知交易。

现在Alice已经将通知交易发送给Bob，让我们看看他是如何解读它的。

作为提醒，Bob必须能够访问Alice的支付代码。如果没有这些信息，正如我们将在下一节中看到的，他将无法推导出Alice创建的密钥对，因此，他将无法访问通过BIP47收到的比特币。目前，Alice的支付代码有效载荷是加密的。让我们一起看看Bob是如何解密它的。

1. Bob监控创建输出到他的通知地址的交易。

2. 当一笔交易的输出指向他的通知地址时，Bob分析它，看它是否包含一个符合BIP47标准的OP_RETURN输出。

3. 如果OP_RETURN有效载荷的第一个字节是0x01，Bob开始寻找可能的共享秘密，使用ECDH：

- Bob选择交易输入中的公钥。也就是说，Alice的名为“A”的公钥：

> A = a·G

- Bob选择与他的个人通知地址关联的私钥“b”：

> b

- Bob通过加点和倍点，在椭圆曲线上计算秘密点“S”（ECDH共享秘密），应用他的私钥“b”到Alice的公钥“A”：

> S = b·A

- Bob确定使他能够解密Alice支付代码有效载荷的盲化因子“f”。与Alice之前计算它的方式相同，Bob将通过对秘密点“S”的x坐标值（x）和在此通知交易中作为输入消耗的UTXO（o）应用HMAC-SHA512来找到“f”：

> f = HMAC-SHA512(o, x)

4. Bob将通知交易中的OP_RETURN数据解读为一个支付代码。他简单地使用盲化因子“f”解密这个潜在支付代码的有效载荷。

- Bob将盲化因子“f”分成两部分： “f”的前32字节将是“f1”，最后32字节将是“f2”。
- Bob解密Alice支付代码公钥的加密x坐标值（x'）：

> x = x' XOR f1

- Bob解密Alice支付代码的加密链代码值（c'）：

> c = c' XOR f2

5. Bob检查Alice支付代码公钥的值是否属于secp256k1群。如果是，他将其解读为有效的支付代码。否则，他忽略该交易。

现在Bob知道了Alice的支付代码，她可以向他发送多达2^32次支付，而不再需要执行像这样的通知交易。

为什么这能工作？Bob如何确定与Alice相同的盲化因子并解密她的支付代码？让我们基于我们刚才描述的，更详细地检查ECDH过程。
首先，我们正在处理对称加密。这意味着加密密钥和解密密钥是相同的值。在这种情况下，通知交易中的密钥是盲化因子（f = f1 || f2）。爱丽丝和鲍勃需要获得相同的f值，而不直接传输它，因为攻击者可能会截获它并解密秘密信息。
这个盲化因子是通过对两个值应用HMAC-SHA512获得的：一个秘密点的x坐标和交易输入中消耗的UTXO。因此，鲍勃需要拥有这两条信息来解密爱丽丝的支付码负载。

对于输入的UTXO，鲍勃可以通过观察通知交易简单地检索它。对于秘密点，鲍勃将不得不使用ECDH。

如在Diffie-Hellman部分所见，通过交换各自的公钥并秘密地将各自的私钥应用于对方的公钥，爱丽丝和鲍勃可以在椭圆曲线上找到一个特定的秘密点。通知交易依赖于这一机制：

> 鲍勃的密钥对：
>
> B = b·G
>
> 爱丽丝的密钥对：
>
> A = a·G
>
> 对于一个秘密点S (x,y)：
>
> S = a·B = a·b·G = b·a·G = b·A

![生成共享秘密的ECDHE图解](assets/19.webp)
现在鲍勃知道了爱丽丝的支付码，他将能够检测到她的BIP47支付并推导出接收比特币的私钥。
![鲍勃解读爱丽丝的通知交易](assets/20.webp)

信用：可重用支付码的分层确定性钱包，Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

如果我们将这个图表与我之前描述的内容相匹配：

- 爱丽丝一侧的“Wallet Pub-Key”对应于：A。

- 鲍勃一侧的“Child Priv-Key 0”对应于：b。

- “Notification Shared Secret”对应于：f。

- “Masked Payment Code”对应于爱丽丝的掩码支付码，即，带有加密负载的：x' 和 c'。

- “Notification Transaction”是包含OP_RETURN的交易。

让我总结一下我们刚刚一起看到的接收和解读通知交易的步骤：

- 鲍勃监控他的通知地址的交易输出。

- 当他检测到一个时，他检索OP_RETURN中包含的信息。

- 鲍勃选择输入公钥并使用ECDH计算一个秘密点。

- 他使用这个秘密点来计算一个HMAC，这是盲化因子。

- 他使用这个盲化因子来解密OP_RETURN中包含的爱丽丝的支付码负载。

### BIP47支付交易。

现在让我们研究BIP47的支付过程。提醒你当前的情况：

- 爱丽丝知道鲍勃的支付码，她简单地从他的网站上检索到了它。

- 由于通知交易，鲍勃知道爱丽丝的支付码。

- 爱丽丝将向鲍勃进行初始支付。她可以以同样的方式进行更多支付。

在向你解释这个过程之前，我认为提醒你我们当前正在处理的索引是重要的：

我们将支付码的派生路径描述如下：m/47'/0'/0'/。

下一个深度将索引分配如下：
- 第一个正常（非加固）的子对用于生成我们在上一节讨论的通知地址：m/47'/0'/0'/0/。
- 正常的子密钥对在ECDH中用于生成BIP47支付接收地址，正如我们将在本节看到的：m/47'/0'/0'/ 从0到2,147,483,647/。

- 加固的子密钥对是临时支付代码：m/47'/0'/0'/ 从0'到2,147,483,647'/。
  每次Alice想要向Bob发送支付时，她都会再次感谢ECDH协议，派生出一个新的唯一的空白地址：
- Alice选择从她个人可重用支付代码派生的第一个私钥：

> a

- Alice选择从Bob的支付代码派生的第一个未使用的公钥。我们将这个公钥称为"B"。它与只有Bob知道的私钥"b"相关联。

> B = b·G

- Alice通过添加和加倍点，将她的私钥"a"应用于Bob的公钥"B"，计算出椭圆曲线上的一个秘密点"S"：

> S = a·B

- 从这个秘密点，Alice将计算共享秘密"s"（小写）。为此，她选择秘密点"S"的x坐标，称为"Sx"，并将这个值传递给SHA256哈希函数。

> s = SHA256(Sx)

不要盲目相信。验证！如果你想了解哈希函数的基本原理，你会在这篇文章中找到所需的信息。如果你不信任NIST（你是对的），并且你想能够详细了解SHA256是如何工作的，我在这篇法语文章中解释了一切。

- Alice使用这个共享的秘密"s"来计算一个比特币支付接收地址。首先，她检查"s"是否在secp256k1曲线的顺序内。如果不是，她增加Bob的公钥的索引以派生另一个共享秘密。

- 其次，她通过在椭圆曲线上添加点"B"和"s·G"来计算一个公钥"K0"。换句话说，Alice将从Bob的支付代码派生的公钥"B"与通过将共享秘密"s"从secp256k1曲线的生成点"G"添加和加倍点计算出的另一个点相加。这个新点代表一个公钥，我们称之为"K0"：

> K0 = B + s·G

- 有了这个公钥"K0"，Alice可以以标准方式派生出一个空白接收地址（例如，Bech32中的SegWit V0）。

一旦Alice拥有了这个属于Bob的接收地址"K0"，她就可以通过选择属于她在她的HD钱包的另一个分支上的一个UTXO，并将其花费到Bob的"K0"地址，来构建一个标准的比特币交易。

![Alice使用BIP47向Bob发送比特币](assets/21.webp)

信用：可重用支付代码用于分层确定性钱包，Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
如果我们将这个图与我之前描述给你的内容匹配：

- Alice一侧的“Child Priv-Key”对应于：a。
- Bob一侧的“Child Pub-Key 0”对应于：B。
- “Payment Secret 0”对应于：s。
- “支付公钥0”对应于：K0。
让我们一起总结一下我们刚刚一起完成的发送BIP47支付的步骤：

- Alice从她的个人支付代码中选择第一个派生的子私钥。
- 她使用ECDH从Bob支付代码中的第一个未使用的派生子公钥计算椭圆曲线上的一个秘密点。
- 她使用这个秘密点通过SHA256计算一个共享秘密。
- 她使用这个共享秘密在椭圆曲线上计算一个新的秘密点。
- 她将这个新的秘密点加到Bob的公钥上。
- 她获得一个新的临时公钥，只有Bob拥有关联的私钥。
- Alice可以向Bob发送一个常规交易，使用派生的临时接收地址。

如果她想要进行第二次支付，她将重复上述步骤，除了她将从Bob的支付代码中选择第二个派生的公钥。也就是说，下一个未使用的键。然后她将拥有属于Bob的第二个接收地址，“K1”。

![Alice为Bob派生了三个BIP47接收地址](assets/22.webp)

信用：可重用支付代码对于分层确定性钱包，Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

她可以继续这样做，派生出多达2^32个属于Bob的空白地址。

从外部观察者的角度来看，通过观察比特币区块链，理论上不可能区分BIP47支付和常规支付。这是Testnet上一个BIP47支付交易的例子：

https://blockstream.info/testnet/tx/94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

TXID:

> 94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

它看起来像一个常规交易，有一个花费的输入，一个210,000 sats的支付输出，和找零。

![比特币支付交易与BIP47](assets/23.webp)

信用：https://blockstream.info/

### 接收BIP47支付并派生私钥。

Alice刚刚向Bob拥有的一个空白BIP47地址进行了她的第一次支付。现在让我们看看Bob如何接收这笔支付。我们还将看到为什么Alice无法访问她刚刚生成的地址的私钥，以及Bob如何检索这个键来花费他刚刚收到的比特币。

一旦Bob从Alice那里收到通知交易，他甚至在她向其发送任何支付之前就派生了BIP47公钥“K0”。因此，他观察到任何对关联地址的支付。实际上，他立即派生了几个他将观察的地址（K0，K1，K2，K3...）。以下是他如何派生这个公钥“K0”的：

- Bob从他的支付代码中选择第一个派生的子私钥。这个私钥被命名为“b”。它与Alice在前一步使用的公钥“B”相关联：

> b

- Bob选择Alice的支付代码中派生的第一个公钥。这个键被命名为“A”。它与Alice在她的计算中使用的私钥“a”相关联，而且只有Alice知道。Bob可以执行此过程，因为他知道Alice的支付代码，该代码通过通知交易传递给他。

> A = a·G
- 鲍勃通过在椭圆曲线上加点和倍点，应用他的私钥“b”到爱丽丝的公钥“A”来计算秘密点“S”。这里我们使用ECDH，它保证了这个点“S”对于鲍勃和爱丽丝来说是相同的。
> S = b·A

- 就像爱丽丝所做的那样，鲍勃分离出这个点“S”的x坐标。我们将这个值命名为“Sx”。他通过SHA256函数处理这个值来找到共享秘密“s”（小写）。

> s = SHA256(Sx)

- 和爱丽丝一样，鲍勃在椭圆曲线上计算点“s·G”。然后，他将这个秘密点加到他的公钥“B”上。然后，他在椭圆曲线上得到一个新的点，他将其解释为公钥“K0”：

> K0 = B + s·G

一旦鲍勃拥有了这个公钥“K0”，他就可以推导出相关的私钥以便花费他的比特币。他是唯一能生成这个数字的人。

- 鲍勃从他的个人支付代码中添加他的派生子私钥“b”。他是唯一能获得“b”值的人。然后，他将“b”加到共享秘密“s”上以获得k0，K0的私钥：

> k0 = b + s
> 多亏了椭圆曲线的群律，鲍勃准确地获得了与爱丽丝使用的公钥相对应的私钥。所以我们有：
> K0 = k0·G

![鲍勃生成他的BIP47接收地址](assets/24.webp)

信用：可重用支付代码对于分层确定性钱包，Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

如果我们将这个图表与我之前描述给你的内容匹配：

- 鲍勃一侧的“Child Priv-Key 0”对应于：b。

- 爱丽丝一侧的“Child Pub-Key 0”对应于：A。

- “Payment Secret 0”对应于：s。

- “Payment Pub-Key 0”对应于：K0。

- “Payment Priv-Key 0”对应于：k0。

让我总结一下我们刚刚一起看到的接收BIP47支付并计算相应私钥的步骤：

- 鲍勃从他的个人支付代码中选择第一个派生的子私钥。

- 他使用ECDH从爱丽丝的链代码中派生的第一个子公钥计算椭圆曲线上的一个秘密点。

- 他使用这个秘密点来计算一个共享秘密，通过SHA256。

- 他使用这个共享秘密来计算椭圆曲线上的一个新的秘密点。

- 他将这个新的秘密点加到他的个人公钥上。

- 他获得一个新的临时公钥，爱丽丝将向这个公钥发送她的第一笔支付。

- 鲍勃通过将他的支付代码中派生的子私钥和共享秘密相加，计算与这个临时公钥相关联的私钥。

由于爱丽丝无法获得“b”，鲍勃的私钥，她无法确定k0，即鲍勃的BIP47接收地址关联的私钥。

从图表上，我们可以这样表示共享秘密“S”的计算：

![使用ECDHE计算共享秘密](assets/25.webp)

一旦通过ECDH找到共享秘密，爱丽丝和鲍勃计算BIP47支付公钥“K0”，鲍勃还计算关联的私钥“k0”：
![从共享秘密派生的BIP47接收地址](assets/26.webp)
### 退款给BIP47支付。

由于Bob知道Alice的可重用支付代码，他已经拥有发送退款给她所需的所有信息。他不需要联系Alice请求任何信息。他只需通过通知交易告知她，特别是这样她就可以使用她的种子恢复她的BIP47地址，然后他也可以给她发送多达2^32次支付。
Bob可以以Alice支付给他的相同方式来退款给Alice。角色互换：

![Bob使用BIP47向Alice退款](assets/27.webp)

信用：可重用支付代码的分层确定性钱包，Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

现在，您已经了解了BIP47这一杰出解决方案的所有细节。

## PayNym的衍生用途。

在Samourai Wallet上实现这个BIP47导致了PayNyms的产生，这些标识符是从用户的支付代码计算出来的。今天，它们的用途远远超出了BIP47的使用。

Samourai团队正在逐步开发基于用户PayNym的整个工具和服务生态系统。其中，显然包括所有允许通过向交易添加熵来优化用户隐私的消费工具，从而增加合理的否认性。

Soroban（基于Tor的加密通信网络）和PayNyms的联合使用极大地优化了构建协作交易时的用户体验，同时保持了良好的安全级别。因此，执行Stowaway（PayJoin）和StonewallX2交易变得容易，无需手动执行设置此类协作交易所需的众多未签名交易的交换。

与使用BIP47不同，由于这些协作交易不需要通知交易，只需链接PayNyms即可使用这些工具。无需连接它们。

如果您想了解更多关于协作交易的信息，以及更广泛地了解Samourai Wallet的所有消费工具，您可以阅读本文中的“消费工具”部分。您将找到每个工具的技术解释和详细教程。

除了这些协作交易之外，最近观察到Samourai团队正在研究与PayNym相关的认证协议：Auth47。这个工具已经实现，例如，它允许在接受这种方法的网站上使用PayNym进行认证。将来，我认为除了在网上认证的可能性之外，Auth47将成为围绕BIP47/PayNym/Samourai生态系统的更大项目的一部分。也许这个协议将被用来进一步优化Samourai Wallet的用户体验，特别是在使用消费工具时。让我们拭目以待...

## 我对BIP47的个人看法。

显然，BIP47的主要缺点是通知交易。它导致用户必须为其挖矿支付费用，这对某些人来说可能令人讨厌。然而，对比特币区块链的“垃圾邮件”论断绝对是不可接受的。任何为其交易支付费用的人都应该能够将其记录在账本上，无论其目的如何。声称反对这一点等于是在倡导审查制度。

可能在未来，会找到其他较少开销的解决方案来传达发送者的支付代码给接收者，并且让接收者安全地存储它。但就目前而言，通知交易仍然是最少妥协的解决方案。
在考虑BIP47的所有好处时，这个缺点仍然可以忽略不计。在所有现有的解决地址重用问题的提案中，它在我看来是最佳解决方案。

如前所述，地址重用的主要来源是交易所。BIP47是唯一一个真正从源头解决这个问题的合理解决方案。任何旨在减少地址重用数量的提案都应该关注这一方面，并将解决方案适应于问题的主要来源。

在可用性方面，尽管其内部工作机制相当复杂，但BIP47的支付程序非常直接。因此，即使是新手用户也可以轻松采用可重用支付代码。

在隐私方面，BIP47非常有趣。正如我在通知交易部分所解释的，支付代码不会泄露有关派生的临时地址的任何信息。因此，它打破了比特币交易与接收者标识符之间的信息流，不同于传统的接收地址使用方式。

最重要的是，BIP47的PayNym实现有效！自2016年以来，它已在Samourai Wallet上可用，并且从今年初开始在Sparrow Wallet上可用。这不是一个科学项目，而是一个经过昨天测试且今天完全可用的解决方案。

希望在未来，这些可重用的支付代码将被生态系统参与者采用，实现在钱包软件中，并被比特币用户使用。

任何真正对用户隐私有积极影响的解决方案都必须被讨论、推动和捍卫，以确保比特币不会成为CA的游乐场和政府的监视工具。
他想到自己到处被迫害和侮辱，现在却听到每个人都说他是所有这些美丽鸟儿中最美的！甚至连接骨木也向他弯曲了枝条，太阳也散发出如此温暖和仁慈的光芒！于是他的羽毛膨胀了，他那纤细的脖子挺直了，他全心全意地呼喊道，“当我还只是一个丑陋的小鸭子时，我怎么能梦想到如此多的幸福。”

## 进一步了解：

- 理解并使用比特币上的CoinJoin。

- 理解比特币钱包的派生路径。

- 安装并使用您的RoninDojo比特币节点。

### 外部资源和致谢：

感谢LaurentMT和Théo Pantamis解释给我听的众多概念，我在这篇文章中使用了这些概念。我希望我已经准确地传达了它们。

感谢Fanis Michalakis对这篇文本的校对和他的专家建议。

- https://bitcoiner.guide/paynym/
- https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
- https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman
- https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman_bas%C3%A9_sur_les_courbes_elliptiques
- https://security.stackexchange.com/questions/46802/what-is-the-difference-between-dhe-and-ecdh#:~:text=The%20difference%20between%20DHE%20and%20ECDH%20in%20two%20bullet%20points,a%20type%20of%20algebraic%20curve).
- https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art060
- https://ee.stanford.edu/~hellman/publications/24.pdf
- https://www.researchgate.net/publication/317339928_A_study_on_diffie-hellman_key_exchange_protocols